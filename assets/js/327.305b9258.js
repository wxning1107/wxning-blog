(window.webpackJsonp=window.webpackJsonp||[]).push([[327],{1206:function(s,_,e){"use strict";e.r(_);var a=e(15),v=Object(a.a)({},(function(){var s=this,_=s.$createElement,e=s._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"如何应对变慢的redis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何应对变慢的redis"}},[s._v("#")]),s._v(" 如何应对变慢的Redis?")]),s._v(" "),e("h1",{attrs:{id:"redis变慢的场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis变慢的场景"}},[s._v("#")]),s._v(" Redis变慢的场景")]),s._v(" "),e("p",[s._v("1.使用复杂度过高的命令或一次查询全量数据；")]),s._v(" "),e("p",[s._v("2.操作 bigkey；")]),s._v(" "),e("p",[s._v("3.大量 key 集中过期；")]),s._v(" "),e("p",[s._v("4.内存达到 maxmemory；")]),s._v(" "),e("p",[s._v("5.客户端使用短连接和 Redis 相连；")]),s._v(" "),e("p",[s._v("6.当 Redis 实例的数据量大时，无论是生成 RDB，还是 AOF 重写，都会导致 fork 耗时严重；")]),s._v(" "),e("p",[s._v("7.AOF 的写回策略为 always，导致每个操作都要同步刷回磁盘；")]),s._v(" "),e("p",[s._v("8.Redis 实例运行机器的内存不足，导致 swap 发生，Redis 需要到 swap 分区读取数据；")]),s._v(" "),e("p",[s._v("9.进程绑定 CPU 不合理；")]),s._v(" "),e("p",[s._v("10.Redis 实例运行机器上开启了透明内存大页机制；")]),s._v(" "),e("p",[s._v("11.网卡压力过大。")]),s._v(" "),e("h1",{attrs:{id:"_1-慢查询命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-慢查询命令"}},[s._v("#")]),s._v(" 1.慢查询命令")]),s._v(" "),e("p",[s._v("如果的确有大量的慢查询命令，有两种处理方式:")]),s._v(" "),e("p",[s._v("1.用其他高效命令代替。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成 线程阻塞。\n2.当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、 SUNION、SINTER 这些命令，以免拖慢 Redis 实例。\n3.因为 KEYS 命令需要遍历存储的键值对，所以操作延时高。KEYS 命令一般不被建议用于生产环境中。")]),s._v(" "),e("h1",{attrs:{id:"_2-过期-key-操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-过期-key-操作"}},[s._v("#")]),s._v(" 2.过期 key 操作")]),s._v(" "),e("p",[s._v("Redis 键值对的 key 可以设置过期时间。默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下:\n1.采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP（默认是 20） 个数的 key，并将其中过期的 key 全部删除;\n2.如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以 下。")]),s._v(" "),e("p",[s._v("如果触发了上面这个算法的第二条，Redis 就会一直删除以释放内存空间。注意， 删除操作是阻塞的(Redis 4.0 后可以用异步线程机制来减少阻塞影响)。所以，一旦该条 件触发，Redis 的线程就会一直执行删除，这样一来，就没办法正常服务其他的键值操作 了，就会进一步引起其他键值操作的延迟增加，Redis 就会变慢。")]),s._v(" "),e("p",[s._v("那么，算法的第二条是怎么被触发的呢?其中一个重要来源，就是频繁使用带有相同时间 参数的 EXPIREAT 命令设置过期 key，这就会导致，在同一秒内有大量的 key 同时过期。")]),s._v(" "),e("h1",{attrs:{id:"_3-aof日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-aof日志"}},[s._v("#")]),s._v(" 3.AOF日志")]),s._v(" "),e("p",[s._v("AOF 日志写回策略为 always 时，Redis 需要确保每个操作记录日志都写回磁盘，如果用后台子线 程异步完成，主线程就无法及时地知道每个操作是否已经完成了，这就不符合 always 策略 的要求了。所以，always 策略并不使用后台子线程来执行。")]),s._v(" "),e("p",[s._v("另外，Redis 使用子进程来进行 AOF 重写时，会对磁盘进行大量 IO 操作，同时，fsync 又需 要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被 阻塞。虽然 fsync 是由后台子线程负责执行的，但是，主线程会监控 fsync 的执行进度。当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如 果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。所以，如果后台子线程执 行的 fsync 频繁阻塞的话(比如 AOF 重写占用了大量的磁盘 IO 带宽)，主线程也会阻 塞，导致 Redis 性能变慢。")]),s._v(" "),e("h1",{attrs:{id:"_4-操作系统-swap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-操作系统-swap"}},[s._v("#")]),s._v(" 4.操作系统 swap")]),s._v(" "),e("p",[s._v("内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发 swap，无论是被换入数据的进程，还是被换出数据的进程，其性 能都会受到慢速磁盘读写的影响。")]),s._v(" "),e("p",[s._v("通常，触发 swap 的原因主要是物理机器内存不足，对于 Redis 而言，有两种常见的情 况:")]),s._v(" "),e("ul",[e("li",[s._v("Redis 实例自身使用了大量的内存，导致物理机器的可用内存不足;")]),s._v(" "),e("li",[s._v("和 Redis 实例在同一台机器上运行的其他进程，在进行大量的文件读写操作。文件读写 本身会占用系统内存，这会导致分配给 Redis 实例的内存量变少，进而触发 Redis 发生 swap。")])]),s._v(" "),e("p",[s._v("针对这个问题，我也给你提供一个解决思路:增加机器的内存或者使用 Redis 集群。")]),s._v(" "),e("h1",{attrs:{id:"_5-操作系统内存大页"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-操作系统内存大页"}},[s._v("#")]),s._v(" 5.操作系统内存大页")]),s._v(" "),e("p",[s._v("Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配，而常 规的内存页分配是按 4KB 的粒度来执行的。")]),s._v(" "),e("p",[s._v("虽然内存大页可以给 Redis 带来内存分配方面的收益，但是，不要忘了，Redis 为了提供 数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，此时，Redis 主线程仍然可以接收客户端写请求。客户端的写请求可能会修改正在进行持久 化的数据。在这一过程中，Redis 就会采用写时复制机制，也就是说，一旦有数据要被修改，Redis 并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。")]),s._v(" "),e("p",[s._v("如果采用了内存大页，那么，即使客户端请求只修改 100B 的数据，Redis 也需要拷贝 2MB 的大页。相反，如果是常规内存页机制，只用拷贝 4KB。两者相比，你可以看到，当 客户端请求修改或新写入数据较多时，内存大页机制将导致大量的拷贝，这就会影响 Redis 正常的访存操作，最终导致性能变慢。")]),s._v(" "),e("p",[s._v("那该怎么办呢?很简单，关闭内存大页，就行了。")])])}),[],!1,null,null,null);_.default=v.exports}}]);