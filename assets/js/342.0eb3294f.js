(window.webpackJsonp=window.webpackJsonp||[]).push([[342],{1184:function(e,t,r){"use strict";r.r(t);var a=r(15),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"幂等性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#幂等性"}},[e._v("#")]),e._v(" 幂等性")]),e._v(" "),r("p",[e._v("将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 "),r("strong",[e._v("At Least Once")]),e._v(" 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 "),r("strong",[e._v("At Most Once")]),e._v(" 语义。")]),e._v(" "),r("p",[e._v("At Least Once 可以保证数据不丢失，但是不能保证数据不重复;相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 "),r("strong",[e._v("Exactly Once")]),e._v(" 语义。在 0.11 版 本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。")]),e._v(" "),r("p",[e._v("0.11 版本的 Kafka，引入了一项重大特性:"),r("strong",[e._v("幂等性")]),e._v("。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即:")]),e._v(" "),r("p",[e._v("At Least Once + 幂等性 = Exactly Once")]),e._v(" "),r("p",[e._v("要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。")]),e._v(" "),r("p",[e._v("Kafka 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对<PID, Partition, SeqNumber>做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。")]),e._v(" "),r("p",[e._v("但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨分区跨会话的 Exactly Once。")])])}),[],!1,null,null,null);t.default=n.exports}}]);