(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{1197:function(_,t,v){"use strict";v.r(t);var r=v(15),i=Object(r.a)({},(function(){var _=this,t=_.$createElement,r=_._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h1",{attrs:{id:"mvcc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvcc"}},[_._v("#")]),_._v(" MVCC")]),_._v(" "),r("p",[_._v("InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。")]),_._v(" "),r("p",[_._v("在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。")]),_._v(" "),r("p",[_._v("这时，你会说这看上去不太现实啊。如果一个库有 100G，那么我启动一个事务，MySQL 就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。")]),_._v(" "),r("p",[_._v("实际上，我们并不需要拷贝出这 100G 的数据。我们先来看看这个快照是怎么实现的。")]),_._v(" "),r("p",[_._v("InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。")]),_._v(" "),r("p",[_._v("而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。")]),_._v(" "),r("p",[_._v("也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。")]),_._v(" "),r("p",[r("img",{attrs:{src:v(784),alt:"img"}})]),_._v(" "),r("p",[_._v("图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。")]),_._v(" "),r("p",[_._v("图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。")]),_._v(" "),r("p",[_._v("我们再来想一下，InnoDB 是怎么定义那个“100G”的快照的。")]),_._v(" "),r("p",[_._v("按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。")]),_._v(" "),r("p",[_._v("因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。")]),_._v(" "),r("p",[_._v("当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。")]),_._v(" "),r("p",[_._v("在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。")]),_._v(" "),r("p",[_._v("数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。")]),_._v(" "),r("p",[_._v("这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。")]),_._v(" "),r("p",[_._v("而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。")]),_._v(" "),r("p",[_._v("这个视图数组把所有的 row trx_id 分成了几种不同的情况。")]),_._v(" "),r("p",[r("img",{attrs:{src:v(785),alt:"img"}})]),_._v(" "),r("p",[_._v("这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：")]),_._v(" "),r("ul",[r("li",[r("p",[_._v("如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；")])]),_._v(" "),r("li",[r("p",[_._v("如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；")])]),_._v(" "),r("li",[r("p",[_._v("如果落在黄色部分，那就包括两种情况")]),_._v(" "),r("ul",[r("li",[_._v("a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；")]),_._v(" "),r("li",[_._v("b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。")])])])])])}),[],!1,null,null,null);t.default=i.exports},784:function(_,t,v){_.exports=v.p+"assets/img/image-20211129093601780.5cc74c47.png"},785:function(_,t,v){_.exports=v.p+"assets/img/image-20211129095510759.dd53a6eb.png"}}]);