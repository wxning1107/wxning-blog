(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{873:function(t,s,_){"use strict";_.r(s);var v=_(15),e=Object(v.a)({},(function(){var t=this,s=t.$createElement,_=t._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"_12-事务隔离级别有哪些-各有哪些优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-事务隔离级别有哪些-各有哪些优缺点"}},[t._v("#")]),t._v(" 12.事务隔离级别有哪些？各有哪些优缺点？")]),t._v(" "),_("p",[_("strong",[t._v("读未提交:")])]),t._v(" "),_("p",[t._v("其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了")]),t._v(" "),_("p",[_("strong",[t._v("读提交:")])]),t._v(" "),_("p",[t._v("一个事务只能读到其他事务已经提交过的数据.解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。")]),t._v(" "),_("p",[_("strong",[t._v("可重复读:")])]),t._v(" "),_("p",[t._v("事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("不可重复读和幻读有什么区别？")]),t._v(" "),_("p",[t._v("不可重复读是读取了其他事务更改的数据，针对update操作。")]),t._v(" "),_("p",[t._v("幻读是读取了其他事务新增的数据，针对insert和delete操作。")])]),t._v(" "),_("p",[_("strong",[t._v("串行化：")])]),t._v(" "),_("p",[t._v("串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。")]),t._v(" "),_("p",[_("br"),_("br"),t._v(" "),_("strong",[t._v("参考：")]),t._v(" https://zhuanlan.zhihu.com/p/117476959")])])}),[],!1,null,null,null);s.default=e.exports}}]);