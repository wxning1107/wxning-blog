(window.webpackJsonp=window.webpackJsonp||[]).push([[245],{949:function(e,t,s){"use strict";s.r(t);var v=s(15),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"散列表-链表案例二-redis-有序集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#散列表-链表案例二-redis-有序集合"}},[e._v("#")]),e._v(" 散列表-链表案例二：Redis 有序集合")]),e._v(" "),s("p",[e._v("在跳表那一节，讲到有序集合的操作时，我稍微做了些简化。实际上，在有序集合中，每个成员对象有两个重要的属性，"),s("strong",[e._v("key")]),e._v("（键值）和"),s("strong",[e._v("score")]),e._v("（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。")]),e._v(" "),s("p",[e._v("举个例子，比如用户积分排行榜有这样一个功能：我们可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。")]),e._v(" "),s("p",[e._v("所以，如果我们细化一下 Redis 有序集合的操作，那就是下面这样：")]),e._v(" "),s("ul",[s("li",[e._v("添加一个成员对象；")]),e._v(" "),s("li",[e._v("按照键值来删除一个成员对象；")]),e._v(" "),s("li",[e._v("按照键值来查找一个成员对象；")]),e._v(" "),s("li",[e._v("按照分值区间查找数据，比如查找积分在 [100, 356] 之间的成员对象；")]),e._v(" "),s("li",[e._v("按照分值从小到大排序成员变量；")])]),e._v(" "),s("p",[e._v("如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似。我们可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。")]),e._v(" "),s("p",[e._v("实际上，Redis 有序集合的操作还有另外一类，也就是查找成员对象的排名（Rank）或者根据排名区间查找成员对象。这个功能单纯用刚刚讲的这种组合结构就无法高效实现了。这块内容我后面的章节再讲。")])])}),[],!1,null,null,null);t.default=_.exports}}]);