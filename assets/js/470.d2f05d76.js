(window.webpackJsonp=window.webpackJsonp||[]).push([[470],{1633:function(t,e,a){"use strict";a.r(e);var l=a(15),s=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"处理高并发流量方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理高并发流量方案"}},[t._v("#")]),t._v(" 处理高并发流量方案")]),t._v(" "),a("p",[a("font",{attrs:{size:"5"}},[a("strong",[t._v("应对高并发大流量常用方法")])])],1),t._v(" "),a("ul",[a("li",[a("p",[t._v("Scale-out（横向扩展），Scale-up（纵向扩展）")])]),t._v(" "),a("li",[a("p",[t._v("缓存")])]),t._v(" "),a("li",[a("p",[t._v("异步")]),t._v(" "),a("p",[t._v("在某些场景下，未处理完成之前，我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。")])])]),t._v(" "),a("p",[t._v("一般来讲，在我们系统设计初期会考虑使用 Scale-up 的方式，因为这种方案足够简单，所谓能用堆砌硬件解决的问题就用硬件来解决，但是当系统并发超过了单机的极限时，我们就要使用 Scale-out 的方式。")]),t._v(" "),a("p",[t._v("对于异步，以方法调用为例，同步调用代表调用方要阻塞等待被调用方法中的逻辑执行完成。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。")]),t._v(" "),a("p",[t._v("异步调用在大规模高并发系统中被大量使用，比如我们熟知的 12306 网站。当我们订票时，页面会显示系统正在排队，这个提示就代表着系统在异步处理我们的订票请求。")])])}),[],!1,null,null,null);e.default=s.exports}}]);