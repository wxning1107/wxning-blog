(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{711:function(_,v,t){_.exports=t.p+"assets/img/image-20211025114504762.9f7ac790.png"},984:function(_,v,t){"use strict";t.r(v);var s=t(15),l=Object(s.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h1",{attrs:{id:"rpc框架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rpc框架"}},[_._v("#")]),_._v(" RPC框架")]),_._v(" "),s("p",[_._v("服务拆分单独部署后，引入的服务跨网络通信的问题（接口响应时间增加），解决该问题的方案是RPC框架。")]),_._v(" "),s("p",[_._v("RPC 的调用步骤：")]),_._v(" "),s("ul",[s("li",[_._v("在 一次 RPC 调用过程中，客户端首先会将调用的类名、方法名、参数名、参数值等信息，序列化成二进制流；")]),_._v(" "),s("li",[_._v("然后客户端将二进制流，通过网络发送给服务端；")]),_._v(" "),s("li",[_._v("服务端接收到二进制流之后，将它反序列化，得到需要调用的类名、方法名、参数名和参数值，再通过动态代理的方式，调用对应的方法得到返回值；")]),_._v(" "),s("li",[_._v("服务端将返回值序列化，再通过网络发送给客户端；")]),_._v(" "),s("li",[_._v("客户端对结果反序列化之后，就可以得到调用的结果了。")])]),_._v(" "),s("p",[s("img",{attrs:{src:t(711),alt:"img"}})]),_._v(" "),s("p",[_._v("从这张图中你可以看到，有网络传输的过程，也有将请求序列化和反序列化的过程， 所以，如果要提升 RPC 框架的性能，需要从 "),s("strong",[_._v("网络传输和序列化")]),_._v(" 两方面来优化。")]),_._v(" "),s("h2",{attrs:{id:"如何提升网络传输性能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何提升网络传输性能"}},[_._v("#")]),_._v(" 如何提升网络传输性能")]),_._v(" "),s("p",[_._v("在网络传输优化中，你首要做的，是选择一种高性能的 I/O 模型。所谓 I/O 模型，就是我们处理 I/O 的方式。而一般单次 I/O 请求会分为两个阶段，每个阶段对于 I/O 的处理方式是不同的。")]),_._v(" "),s("p",[s("strong",[_._v("首先，I/O 会经历一个等待资源的阶段，")]),_._v(" 比方说，等待网络传输数据可用，在这个过程中我们对 I/O 会有两种处理方式：")]),_._v(" "),s("ul",[s("li",[_._v("阻塞。指的是在数据不可用时，I/O 请求一直阻塞，直到数据返回；")]),_._v(" "),s("li",[_._v("非阻塞。指的是数据不可用时，I/O 请求立即返回，直到被通知资源可用为止。")])]),_._v(" "),s("p",[s("strong",[_._v("然后是使用资源的阶段，")]),_._v(" 比如说从网络上接收到数据，并且拷贝到应用程序的缓冲区里面。在这个阶段我们也会有两种处理方式：")]),_._v(" "),s("ul",[s("li",[_._v("同步处理。指的是 I/O 请求在读取或者写入数据时会阻塞，直到读取或者写入数据完成；")]),_._v(" "),s("li",[_._v("异步处理。指的是 I/O 请求在读取或者写入数据时立即返回，当操作系统处理完成 I/O 请求，并且将数据拷贝到用户提供的缓冲区后，再通知应用 I/O 请求执行完成。")])]),_._v(" "),s("p",[_._v("将这两个阶段的四种处理方式，做一些排列组合，再做一些补充，就得到了我们常见的五种 I/O 模型：")]),_._v(" "),s("ul",[s("li",[_._v("同步阻塞 I/O")]),_._v(" "),s("li",[_._v("同步非阻塞 I/O")]),_._v(" "),s("li",[_._v("同步多路 I/O 复用")]),_._v(" "),s("li",[_._v("信号驱动 I/O")]),_._v(" "),s("li",[_._v("异步 I/O")])]),_._v(" "),s("p",[_._v("这五种 I/O 模型，你需要理解它们的区别和特点，不过在理解上你可能会有些难度，所以我来做个比喻，方便你理解。")]),_._v(" "),s("p",[_._v("我们来把 I/O 过程比喻成烧水倒水的过程，等待资源（就是烧水的过程），使用资源（就是倒水的过程）：")]),_._v(" "),s("ul",[s("li",[_._v("如果你站在炤台边上一直等着（等待资源）水烧开，然后倒水（使用资源），那么就是同步阻塞 I/O；")]),_._v(" "),s("li",[_._v("如果你偷点儿懒，在烧水的时候躺在沙发上看会儿电视（不再时时刻刻等待资源），但是还是要时不时的去看看水开了没有，一旦水开了，马上去倒水（使用资源），那么这就是同步非阻塞 I/O；")]),_._v(" "),s("li",[_._v("如果你想要洗澡，需要同时烧好多壶水，那你就在看电视的间隙去看看哪壶水开了（等待多个资源），哪一壶开了就先倒哪一壶，这样就加快了烧水的速度，这就是同步多路 I/O 复用；")]),_._v(" "),s("li",[_._v("不过你发现自己总是跑厨房去看水开了没，太累了，于是你考虑给你的水壶加一个报警器（信号），只要水开了就马上去倒水，这就是信号驱动 I/O；")]),_._v(" "),s("li",[_._v("最后一种就高级了，你发明了一个智能水壶，在水烧好后自动就可以把水倒好，这就是异步 I/O。")])]),_._v(" "),s("p",[_._v("那么，选择好了一种高性能的 I/O 模型，是不是就能实现，数据在网络上的高效传输呢？其实并没有那么简单，网络性能的调优涉及很多方面， "),s("strong",[_._v("其中不可忽视的一项就是网络参数的调优，")]),_._v(" 接下来，我带你了解其中一个典型例子。当然，你可以结合网络基础知识，以及成熟 RPC 框架（比如 Dubbo）的源码来深入了解，网络参数调优的方方面面。")]),_._v(" "),s("p",[s("strong",[_._v("在之前的项目中，")]),_._v(" 我的团队曾经写过一个简单的 RPC 通信框架。在进行测试的时候发现，远程调用一个空业务逻辑的方法时，平均响应时间居然可以到几十毫秒，这明显不符合我们的预期，在我们看来，运行一个空的方法，应该在 1 毫秒之内可以返回。于是，我先在测试的时候使用 tcpdump 抓了包，发现一次请求的 Ack 包竟然要经过 40ms 才返回。在网上 google 了一下原因，发现原因和一个叫做 tcp_nodelay 的参数有关。 "),s("strong",[_._v("这个参数是什么作用呢？")])]),_._v(" "),s("p",[_._v("tcp 协议的包头有 20 字节，ip 协议的包头也有 20 字节，如果仅仅传输 1 字节的数据，在网络上传输的就有 20 + 20 + 1 = 41 字节，其中真正有用的数据只有 1 个字节，这对效率和带宽是极大的浪费。所以在 1984 年的时候，John Nagle 提出了以他的名字命名的 Nagle`s 算法， "),s("strong",[_._v("他期望：")])]),_._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),s("p",[_._v("如果是连续的小数据包，大小没有一个 MSS（Maximum Segment Size，最大分段大小），并且还没有收到之前发送的数据包的 Ack 信息，那么这些小数据包就会在发送端暂存起来，直到小数据包累积到一个 MSS，或者收到一个 Ack 为止。")])]),_._v(" "),s("p",[_._v("这原本是为了减少不必要的网络传输，但是如果接收端开启了 DelayedACK（延迟 ACK 的发送，这样可以合并多个 ACK，提升网络传输效率），"),s("strong",[_._v("那就会发生，")]),_._v(" 发送端发送第一个数据包后，接收端没有返回 ACK，这时发送端发送了第二个数据包，因为 Nagle`s 算法的存在，并且第一个发送包的 ACK 还没有返回，所以第二个包会暂存起来。而 DelayedACK 的超时时间，默认是 40ms，所以一旦到了 40ms，接收端回给发送端 ACK，那么发送端才会发送第二个包， "),s("strong",[_._v("这样就增加了延迟。")])]),_._v(" "),s("p",[s("strong",[_._v("解决的方式非常简单：")]),_._v(" 只要在 socket 上开启 tcp_nodelay 就好了，这个参数关闭了 Nagle`s 算法，这样发送端就不需要等到上一个发送包的 ACK 返回，直接发送新的数据包就好了。这对于强网络交互的场景来说非常的适用，基本上，如果你要自己实现一套网络框架，tcp_nodelay 这个参数最好是要开启的。")]),_._v(" "),s("h2",{attrs:{id:"选择合适的序列化方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选择合适的序列化方式"}},[_._v("#")]),_._v(" 选择合适的序列化方式")]),_._v(" "),s("p",[s("strong",[_._v("在选择序列化方式的时候需要考虑哪些因素呢？")])]),_._v(" "),s("p",[_._v("需要考虑的肯定是性能，是否可以跨语言，跨平台")]),_._v(" "),s("p",[s("strong",[_._v("序列化备选方案主要有以下几种：")])]),_._v(" "),s("p",[_._v("首先是大家熟知的 JSON，它起源于 JavaScript，是一种最广泛使用的序列化协议，它的优势简单易用，人言可读，同时在性能上相比 XML 有比较大的优势。")]),_._v(" "),s("p",[_._v("另外的 Thrift 和 Protobuf 都是需要引入 IDL（Interface description language）的，也就是需要按照约定的语法写一个 IDL 文件，然后通过特定的编译器将它转换成各语言对应的代码，从而实现跨语言的特点。")]),_._v(" "),s("p",[s("strong",[_._v("Thrift")]),_._v(" 是 Facebook 开源的高性能的序列化协议，也是一个轻量级的 RPC 框架；"),s("strong",[_._v("Protobuf")]),_._v(" 是谷歌开源的序列化协议。它们的共同特点是，无论在空间上还是时间上都有着很高的性能，缺点就是由于 IDL 存在带来一些使用上的不方便。")]),_._v(" "),s("p",[_._v("那么，你要如何选择这几种序列化协议呢？ "),s("strong",[_._v("这里我给你几点建议：")])]),_._v(" "),s("ul",[s("li",[_._v("如果对于性能要求不高，在传输数据占用带宽不大的场景下，可以使用 JSON 作为序列化协议；")]),_._v(" "),s("li",[_._v("如果对于性能要求比较高，那么使用 Thrift 或者 Protobuf 都可以。而 Thrift 提供了配套的 RPC 框架，所以想要一体化的解决方案，你可以优先考虑 Thrift；")]),_._v(" "),s("li",[_._v("在一些存储的场景下，比如说你的缓存中存储的数据占用空间较大，那么你可以考虑使用 Protobuf 替换 JSON，作为存储数据的序列化方式。")])])])}),[],!1,null,null,null);v.default=l.exports}}]);