(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{1230:function(t,v,_){"use strict";_.r(v);var o=_(15),i=Object(o.a)({},(function(){var t=this,v=t.$createElement,o=t._self._c||v;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"分布式事务"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[t._v("#")]),t._v(" 分布式事务")]),t._v(" "),o("p",[t._v("实现分布式事务有以下 3 种基本方法：")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("基于 XA 协议的二阶段提交协议方法；")])]),t._v(" "),o("li",[o("p",[t._v("三阶段提交协议方法；")])]),t._v(" "),o("li",[o("p",[t._v("基于消息的最终一致性方法。")])])]),t._v(" "),o("p",[t._v("其中，基于 XA 协议的二阶段提交协议方法和三阶段提交协议方法，采用了强一致性，遵从 ACID，基于消息的最终一致性方法，采用了最终一致性，遵从 BASE 理论。")]),t._v(" "),o("p",[o("font",{attrs:{size:"5"}},[o("strong",[t._v("基于 XA 协议的二阶段提交方法")])])],1),t._v(" "),o("p",[t._v("XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。因此，XA 协议可以分为两部分，即事务管理器和本地资源管理器。")]),t._v(" "),o("p",[t._v("XA 实现分布式事务的原理，类似于集中式算法：事务管理器作为协调者，负责各个本地资源的提交和回滚；而资源管理器就是分布式事务的参与者，通常由数据库实现，比如 Oracle、DB2 等商业数据库都实现了 XA 接口。")]),t._v(" "),o("p",[t._v("基于 XA 协议的二阶段提交方法中，二阶段提交协议（The two-phase commit protocol，2PC），用于保证分布式系统中事务提交时的数据一致性，是 XA 在全局事务中用于协调多个资源的机制。")]),t._v(" "),o("p",[t._v("那么，两阶段提交协议如何保证分布在不同节点上的分布式事务的一致性呢？为了保证它们的一致性，我们需要引入一个协调者来管理所有的节点，并确保这些节点正确提交操作结果，若提交失败则放弃事务。接下来，我们看看两阶段提交协议的具体过程。")]),t._v(" "),o("p",[t._v("两阶段提交协议的执行过程，分为"),o("strong",[t._v("投票")]),t._v("（voting）和"),o("strong",[t._v("提交")]),t._v("（commit）两个阶段。")]),t._v(" "),o("p",[o("strong",[t._v("投票为第一阶段")]),t._v("，协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的 CanCommit 请求，并等待参与者的响应。参与者接收到请求后，会执行请求中的事务操作，记录日志信息但不提交，待参与者执行成功，则向协调者发送“Yes”消息，表示同意操作；若不成功，则发送“No”消息，表示终止操作。")]),t._v(" "),o("p",[t._v("当所有的参与者都返回了操作结果（Yes 或 No 消息）后，"),o("strong",[t._v("系统进入了提交阶段")]),t._v("。在提交阶段，协调者会根据所有参与者返回的信息向参与者发送 DoCommit 或 DoAbort 指令：")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("若协调者收到的都是“Yes”消息，则向参与者发送“DoCommit”消息，参与者会完成剩余的操作并释放资源，然后向协调者返回“HaveCommitted”消息；")])]),t._v(" "),o("li",[o("p",[t._v("如果协调者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息，此时发送“Yes”的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送“HaveCommitted”消息；")])]),t._v(" "),o("li",[o("p",[t._v("协调者接收到“HaveCommitted”消息，就意味着整个事务结束了。")])])]),t._v(" "),o("p",[t._v("接下来，我以用户 A 要在网上下单购买 100 件 T 恤为例，重点与你介绍下单操作和减库存操作这两个操作，帮助你加深对二阶段提交协议的理解。")]),t._v(" "),o("p",[t._v("第一阶段：订单系统中将与用户 A 有关的订单数据库锁住，准备好增加一条关于用户 A 购买 100 件 T 恤的信息，并将同意消息“Yes”回复给协调者。而库存系统由于 T 恤库存不足，出货失败，因此向协调者回复了一个终止消息“No”。")]),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(426),alt:"image-20220417093146236"}}),t._v(" "),o("p",[t._v("第二阶段：由于库存系统操作不成功，因此，协调者就会向订单系统和库存系统发送“DoAbort”消息。订单系统接收到“DoAbort”消息后，将系统内的数据退回到没有用户 A 购买 100 件 T 恤的版本，并释放锁住的数据库资源。订单系统和库存系统完成操作后，向协调者发送“HaveCommitted”消息，表示完成了事务的撤销操作。")]),t._v(" "),o("p",[t._v("至此，用户 A 购买 100 件 T 恤这一事务已经结束，用户 A 购买失败。")]),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(427),alt:"image-20220417093146236"}}),t._v(" "),o("p",[t._v("由上述流程可以看出，二阶段提交的算法思路可以概括为：协调者下发请求事务操作，参与者将操作结果通知协调者，协调者根据所有参与者的反馈结果决定各参与者是要提交操作还是撤销操作。")]),t._v(" "),o("p",[t._v("虽然基于 XA 的二阶段提交算法基本满足了事务的 ACID 特性，但依然有些不足。")]),t._v(" "),o("ul",[o("li",[o("p",[o("strong",[t._v("同步阻塞问题")]),t._v("：二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("单点故障问题")]),t._v("：基于 XA 的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("数据不一致问题")]),t._v("：在提交阶段，当协调者向参与者发送 DoCommit 请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。")])])]),t._v(" "),o("p",[o("font",{attrs:{size:"5"}},[o("strong",[t._v("三阶段提交方法")])])],1),t._v(" "),o("p",[t._v("三阶段提交协议（Three-phase commit protocol，3PC），是对二阶段提交（2PC）的改进。"),o("strong",[t._v("为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了超时机制和准备阶段。")])]),t._v(" "),o("ul",[o("li",[o("p",[t._v("同时在协调者和参与者中引入超时机制。如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务。")])]),t._v(" "),o("li",[o("p",[t._v("在第一阶段和第二阶段中间引入了一个准备阶段，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。")])])]),t._v(" "),o("p",[t._v("也就是说，除了引入超时机制之外，3PC 把 2PC 的提交阶段一分为二，这样三阶段提交协议就有 CanCommit、PreCommit、DoCommit 三个阶段。")]),t._v(" "),o("p",[o("strong",[t._v("第一，CanCommit 阶段。")])]),t._v(" "),o("p",[t._v("CanCommit 阶段与 2PC 的投票阶段类似：协调者向参与者发送请求操作（CanCommit 请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到 CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。")]),t._v(" "),o("p",[t._v("CanCommit 阶段不同节点之间的事务请求成功和失败的流程，如下所示。")]),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(428),alt:"image-20220417093146236"}}),t._v(" "),o("p",[o("strong",[t._v("第二，PreCommit 阶段。")])]),t._v(" "),o("p",[t._v("协调者根据参与者的回复情况，来决定是否可以进行 PreCommit 操作。")]),t._v(" "),o("ul",[o("li",[o("p",[t._v("如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：")]),t._v(" "),o("ul",[o("li",[o("p",[o("strong",[t._v("发送预提交请求")]),t._v("。协调者向参与者发送 PreCommit 请求，进入预提交阶段。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("事务预提交")]),t._v("。参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("响应反馈")]),t._v("。如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。")])])])]),t._v(" "),o("li",[o("p",[t._v("假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：")]),t._v(" "),o("ul",[o("li",[o("p",[o("strong",[t._v("发送中断请求")]),t._v("。协调者向所有参与者发送“Abort”消息。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("终断事务")]),t._v("。参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的终断操作。")])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("预执行阶段")]),t._v("，不同节点上事务执行成功和失败的流程，如下所示。")])])])])]),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(429),alt:"image-20220417093146236"}}),t._v(" "),o("p",[o("strong",[t._v("第三，DoCommit 阶段。")])]),t._v(" "),o("p",[t._v("DoCmmit 阶段进行真正的事务提交，根据 PreCommit 阶段协调者发送的消息，进入执行提交阶段或事务中断阶段。")]),t._v(" "),o("ul",[o("li",[o("p",[o("strong",[t._v("执行提交阶段：")])]),t._v(" "),o("ul",[o("li",[o("p",[t._v("发送提交请求。协调者接收到所有参与者发送的 Ack 响应，从预提交状态进入到提交状态，并向所有参与者发送 DoCommit 消息。")])]),t._v(" "),o("li",[o("p",[t._v("事务提交。参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。")])]),t._v(" "),o("li",[o("p",[t._v("响应反馈。参与者提交完事务之后，向协调者发送 Ack 响应。")])]),t._v(" "),o("li",[o("p",[t._v("完成事务。协调者接收到所有参与者的 Ack 响应之后，完成事务。")])])])]),t._v(" "),o("li",[o("p",[o("strong",[t._v("事务中断阶段：")])]),t._v(" "),o("ul",[o("li",[o("p",[t._v("发送中断请求。协调者向所有参与者发送 Abort 请求。")])]),t._v(" "),o("li",[o("p",[t._v("事务回滚。参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo 信息执行事务的回滚操作，并释放所有锁住的资源。")])]),t._v(" "),o("li",[o("p",[t._v("反馈结果。参与者完成事务回滚之后，向协调者发送 Ack 消息。")])]),t._v(" "),o("li",[o("p",[t._v("终断事务。协调者接收到参与者反馈的 Ack 消息之后，执行事务的终断，并结束事务。")])])])])]),t._v(" "),o("p",[t._v("执行阶段不同节点上事务执行成功和失败 (事务终断) 的流程，如下所示。")]),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(430),alt:"image-20220417093146236"}}),t._v(" "),o("p",[t._v("在 DoCommit 阶段，当参与者向协调者发送 Ack 消息后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交那样被阻塞住。")]),t._v(" "),o("p",[o("font",{attrs:{size:"5"}},[o("strong",[t._v("基于分布式消息的最终一致性方案")])])],1),t._v(" "),o("p",[t._v("2PC 和 3PC 这两种方法，有两个共同的缺点，一是都需要锁定资源，降低系统性能；二是，没有解决数据不一致的问题。因此，便有了通过分布式消息来确保事务最终一致性的方案。")]),t._v(" "),o("p",[t._v("在 eBay 的分布式系统架构中，架构师解决一致性问题的核心思想就是：将需要分布式处理的事务通过消息或者日志的方式异步执行，消息或日志可以存到本地文件、数据库或消息队列中，再通过业务规则进行失败重试。这个案例，就是使用基于分布式消息的最终一致性方案解决了分布式事务的问题。")]),t._v(" "),o("p",[t._v("基于分布式消息的最终一致性方案的事务处理，引入了一个消息中间件（Message Queue，MQ），用于在多个应用之间进行消息传递。基于消息中间件协商多个节点分布式事务执行操作的示意图，如下所示。")]),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(431),alt:"image-20220417093146236"}}),t._v(" "),o("p",[t._v("仍然以网上购物为例。假设用户 A 在某电商平台下了一个订单，需要支付 50 元，发现自己的账户余额共 150 元，就使用余额支付，支付成功之后，订单状态修改为支付成功，然后通知仓库发货。")]),t._v(" "),o("p",[t._v("在该事件中，涉及到了订单系统、支付系统、仓库系统，这三个系统是相互独立的应用，通过远程服务进行调用。")]),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(432),alt:"image-20220417093146236"}}),t._v(" "),o("p",[t._v("根据基于分布式消息的最终一致性方案，用户 A 通过终端手机首先在订单系统上操作，然后整个购物的流程如下所示。")]),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(433),alt:"image-20220417093146236"}}),t._v(" "),o("p",[t._v("1.订单系统把订单消息发给消息中间件，消息状态标记为“待确认”。")]),t._v(" "),o("p",[t._v("2.消息中间件收到消息后，进行消息持久化操作，即在消息存储系统中新增一条状态为“待发送”的消息。")]),t._v(" "),o("p",[t._v("3.消息中间件返回消息持久化结果（成功 / 失败），订单系统根据返回结果判断如何进行业务操作。失败，放弃订单，结束（必要时向上层返回失败结果）；成功，则创建订单。")]),t._v(" "),o("p",[t._v("4.订单操作完成后，把操作结果（成功 / 失败）发送给消息中间件。")]),t._v(" "),o("p",[t._v("5.消息中间件收到业务操作结果后，根据结果进行处理：失败，删除消息存储中的消息，结束；成功，则更新消息存储中的消息状态为“待发送（可发送）”，并执行消息投递。")]),t._v(" "),o("p",[t._v("6.如果消息状态为“可发送”，则 MQ 会将消息发送给支付系统，表示已经创建好订单，需要对订单进行支付。支付系统也按照上述方式进行订单支付操作。")]),t._v(" "),o("p",[t._v("7.订单系统支付完成后，会将支付消息返回给消息中间件，中间件将消息传送给订单系统。订单系统再调用库存系统，进行出货操作。")]),t._v(" "),o("p",[t._v("可以看出，分布式事务中，当且仅当所有的事务均成功时整个流程才成功。所以，分布式事务的一致性是实现分布式事务的关键问题，目前来看还没有一种很简单、完美的方案可以应对所有场景。")]),t._v(" "),o("p",[o("font",{attrs:{size:"5"}},[o("strong",[t._v("三种实现方式对比")])])],1),t._v(" "),o("img",{staticStyle:{zoom:"60%"},attrs:{src:_(434),alt:"image-20220417093146236"}}),t._v(" "),o("hr"),t._v(" "),o("p",[t._v("参考："),o("a",{attrs:{href:"https://www.bilibili.com/video/BV1X3411q7bC/?spm_id_from=333.788",target:"_blank",rel:"noopener noreferrer"}},[t._v("阿里巴巴Seata分布式事务解决方案"),o("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=i.exports},426:function(t,v,_){t.exports=_.p+"assets/img/image-20220417093146236.0d2bc94b.png"},427:function(t,v,_){t.exports=_.p+"assets/img/image-20220417093351833.d12a38a0.png"},428:function(t,v,_){t.exports=_.p+"assets/img/image-20220417093732343.c5a16e54.png"},429:function(t,v,_){t.exports=_.p+"assets/img/image-20220417094047458.150e4594.png"},430:function(t,v,_){t.exports=_.p+"assets/img/image-20220417094406980.ed000b54.png"},431:function(t,v,_){t.exports=_.p+"assets/img/image-20220417095633013.8d58c7b3.png"},432:function(t,v,_){t.exports=_.p+"assets/img/image-20220417095706448.c809e8d9.png"},433:function(t,v,_){t.exports=_.p+"assets/img/image-20220417095743323.3f3d5329.png"},434:function(t,v,_){t.exports=_.p+"assets/img/image-20220417095918556.5e055203.png"}}]);