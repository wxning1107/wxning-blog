(window.webpackJsonp=window.webpackJsonp||[]).push([[423],{1491:function(t,r,e){"use strict";e.r(r);var s=e(15),a=Object(s.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"实战测试题二"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实战测试题二"}},[t._v("#")]),t._v(" 实战测试题二")]),t._v(" "),e("p",[t._v("电商交易系统中，订单数据一般都会很大，我们一般都分库分表来存储。假设我们分了 10 个库并存储在不同的机器上，在不引入复杂的分库分表中间件的情况下，我们希望开发一个小的功能，能够快速地查询金额最大的前 K 个订单（K 是输入参数，可能是 1、10、1000、10000，假设最大不会超过 10 万）。"),e("strong",[t._v("如果你是这个功能的设计开发负责人，你会如何设计一个比较详细的、可以落地执行的设计方案呢？")])]),t._v(" "),e("p",[t._v("为了方便你设计，我先交代一些必要的背景，在设计过程中，如果有其他需要明确的背景，你可以自行假设。")]),t._v(" "),e("ul",[e("li",[t._v("数据库中，订单表的金额字段上建有索引，我们可以通过 select order by limit 语句来获取数据库中的数据；")]),t._v(" "),e("li",[t._v("我们的机器的可用内存有限，比如只有几百 M 剩余可用内存。希望你的设计尽量节省内存，不要发生 Out of Memory Error。")])]),t._v(" "),e("h1",{attrs:{id:"题目解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题目解析"}},[t._v("#")]),t._v(" 题目解析")]),t._v(" "),e("p",[t._v("解决这个题目的基本思路我想你应该能想到，就是借助归并排序中的合并函数，这个我们在排序以及堆的应用那一节中讲过。")]),t._v(" "),e("p",[t._v("我们从每个数据库中，通过 select order by limit 语句，各取局部金额最大的订单，把取出来的 10 个订单放到优先级队列中，取出最大值（也就是大顶堆堆顶数据），就是全局金额最大的订单。然后再从这个全局金额最大订单对应的数据库中，取出下一条订单（按照订单金额从大到小排列的），然后放到优先级队列中。一直重复上面的过程，直到找到金额前 K（K 是用户输入的）大订单。")]),t._v(" "),e("p",[t._v("从算法的角度看起来，这个方案非常完美，但是，从实战的角度来说，这个方案并不高效，甚至很低效。因为我们忽略了，数据库读取数据的性能才是这个问题的性能瓶颈。所以，我们要尽量减少 SQL 请求，每次多取一些数据出来，那一次性取出多少才合适呢？这就比较灵活、比较有技巧了。一次性取太多，会导致数据量太大，SQL 执行很慢，还有可能触发超时，而且，我们题目中也说了，内存有限，太多的数据加载到内存中，还有可能导致 Out of Memory Error。")]),t._v(" "),e("p",[t._v("所以，一次性不能取太多数据，也不能取太少数据，到底是多少，还要根据实际的硬件环境做 benchmark 测试去找最合适的。")])])}),[],!1,null,null,null);r.default=a.exports}}]);