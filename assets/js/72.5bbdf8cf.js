(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{601:function(t,a,s){t.exports=s.p+"assets/img/image-20211022135000780.49b866a8.png"},602:function(t,a,s){t.exports=s.p+"assets/img/image-20211022135353675.026634bd.png"},838:function(t,a,s){"use strict";s.r(a);var e=s(15),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"池化技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#池化技术"}},[t._v("#")]),t._v(" 池化技术")]),t._v(" "),e("h2",{attrs:{id:"mysql连接耗时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql连接耗时"}},[t._v("#")]),t._v(" MySQL连接耗时")]),t._v(" "),e("p",[t._v("抓包：")]),t._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("tcpdump -i bond0 -nn -tttt port "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4490")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("抓取了线上 MySQL 建立连接的网络包来做分析，从抓包结果来看，整个 MySQL 的连接过程可以分为两部分：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(601),alt:"img"}})]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("第一部分是前三个数据包")])]),t._v(" "),e("p",[t._v("第一个数据包是客户端向服务端发送的一个 SYN 包，")]),t._v(" "),e("p",[t._v("第二个包是服务端回给客户端的 ACK 包以及一个 SYN 包，")]),t._v(" "),e("p",[t._v("第三个包是客户端回给服务端的 ACK 包，熟悉 TCP 协议的同学可以看出这是一个 TCP 的三次握手过程。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("第二部分是 MySQL 服务端校验客户端密码的过程。")])]),t._v(" "),e("p",[t._v("其中第一个包是服务端发给客户端要求认证的报文，")]),t._v(" "),e("p",[t._v("第二和第三个包是客户端将加密后的密码发送给服务端的包，")]),t._v(" "),e("p",[t._v("最后两个包是服务端回给客户端认证 OK 的报文。")])])]),t._v(" "),e("p",[t._v("从图中，你可以看到整个连接过程大概消耗了 4ms（969012-964904）。所以，数据库建连耗时甚至比一个sql执行时间还要久，采用数据库连接池")]),t._v(" "),e("h2",{attrs:{id:"java线程池"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java线程池"}},[t._v("#")]),t._v(" Java线程池")]),t._v(" "),e("p",[t._v("JDK 1.5 中引入的 "),e("code",[t._v("ThreadPoolExecutor")]),t._v(" 就是一种线程池的实现，它有两个重要的参数："),e("code",[t._v("coreThreadCount")]),t._v(" 和 "),e("code",[t._v("maxThreadCount")]),t._v("，这两个参数控制着线程池的执行过程：")]),t._v(" "),e("ul",[e("li",[t._v("如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；")]),t._v(" "),e("li",[t._v("如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；")]),t._v(" "),e("li",[t._v("当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；")]),t._v(" "),e("li",[t._v("当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(602),alt:"img"}})]),t._v(" "),e("p",[t._v("JDK 实现的这个线程池优 "),e("strong",[t._v("先把任务放入队列暂存起来，而不是创建更多的线程")])])])}),[],!1,null,null,null);a.default=v.exports}}]);