(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{1235:function(t,s,e){"use strict";e.r(s);var n=e(15),a=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"选择排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[t._v("#")]),t._v(" 选择排序")]),t._v(" "),n("p",[t._v("选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。")]),t._v(" "),n("p",[n("img",{attrs:{src:e(580),alt:"img"}})]),t._v(" "),n("p",[t._v("选择排序空间复杂度为 O(1)，是一种原地排序算法。")]),t._v(" "),n("p",[t._v("时间复杂度为 O(n^2)。")]),t._v(" "),n("p",[t._v("但是选择排序是一种不稳定的排序算法，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。")])])}),[],!1,null,null,null);s.default=a.exports},580:function(t,s,e){t.exports=e.p+"assets/img/image-20211103114056046.cb67b6ec.png"}}]);