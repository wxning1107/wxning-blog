(window.webpackJsonp=window.webpackJsonp||[]).push([[265],{1113:function(t,a,s){t.exports=s.p+"assets/img/image-20211025171437166.f55d1905.png"},1591:function(t,a,s){"use strict";s.r(a);var v=s(15),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"服务监控"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务监控"}},[t._v("#")]),t._v(" 服务监控")]),t._v(" "),v("h2",{attrs:{id:"如何采集数据指标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何采集数据指标"}},[t._v("#")]),t._v(" 如何采集数据指标")]),t._v(" "),v("p",[v("strong",[t._v("首先，")]),t._v(" Agent 是一种比较常见的，采集数据指标的方式。我们通过在数据源的服务器上，部署自研或者开源的 Agent，来收集收据，发送给监控系统，实现数据的采集。")]),t._v(" "),v("p",[t._v("另一种很重要的数据获取方式，**是在代码中埋点。**这个方式与 Agent 的不同之处在于，Agent 主要收集的是组件服务端的信息，而埋点则是从客户端的角度，来描述所使用的组件，和服务的性能和可用性。可以在资源客户端中，直接计算调用资源或者服务的耗时、调用量、慢请求数，并且发送给监控服务器。"),v("strong",[t._v("这里你需要注意一点，")]),t._v(" 由于调用缓存、数据库的请求量会比较高，一般会单机也会达到每秒万次，如果不经过任何优化，把每次请求耗时都发送给监控服务器，那么，监控服务器会不堪重负。所以，我们一般会在埋点时，先做一些汇总。比如，每隔 10 秒汇总这 10 秒内，对同一个资源的请求量总和、响应时间分位值、错误数等，然后发送给监控服务器。这样，就可以大大减少发往监控服务器的请求量了。")]),t._v(" "),v("p",[v("strong",[t._v("最后，")]),t._v(" 日志也是你监控数据的重要来源之一。")]),t._v(" "),v("h2",{attrs:{id:"监控数据的处理和存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#监控数据的处理和存储"}},[t._v("#")]),t._v(" 监控数据的处理和存储")]),t._v(" "),v("p",[t._v("在采集到监控数据之后，你就可以对它们进行处理和存储了，在此之前，我们一般会先用消息队列来承接数据，主要的作用是削峰填谷，防止写入过多的监控数据，让监控服务产生影响。")]),t._v(" "),v("p",[t._v("与此同时，我们一般会部署两个队列处理程序，来消费消息队列中的数据。")]),t._v(" "),v("p",[t._v("一个处理程序接收到数据后，把数据写入到 Elasticsearch，然后通过 Kibana 展示数据，这份数据主要是用来做原始数据的查询；")]),t._v(" "),v("p",[t._v("另一个处理程序是一些流式处理的中间件，比如，Spark、Storm。它们从消息队列里，接收数据后会做一些处理，这些处理包括：")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("解析数据格式，尤其是日志格式")]),t._v(" 从里面提取诸如请求量、响应时间、请求 URL 等数据；")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("对数据做一些聚合运算")])]),t._v(" "),v("p",[t._v("比如，针对 Tomcat 访问日志，可以计算同一个 URL 一段时间之内的请求量、响应时间分位值、非 200 请求量的大小等等。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("将数据存储在时间序列数据库中")])]),t._v(" "),v("p",[t._v("这类数据库的特点是，可以对带有时间标签的数据，做更有效的存储，而我们的监控数据恰恰带有时间标签，并且按照时间递增，非常适合存储在时间序列数据库中。目前业界比较常用的时序数据库有 InfluxDB、OpenTSDB、Graphite，各大厂的选择均有不同，你可以选择一种熟悉的来使用。")])])]),t._v(" "),v("p",[v("strong",[t._v("最后，")]),t._v(" 你就可以通过 Grafana 来连接时序数据库，将监控数据绘制成报表，呈现给开发和运维的同学了。")]),t._v(" "),v("p",[v("img",{attrs:{src:s(1113),alt:"img"}})])])}),[],!1,null,null,null);a.default=_.exports}}]);