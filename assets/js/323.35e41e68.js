(window.webpackJsonp=window.webpackJsonp||[]).push([[323],{1241:function(t,s,a){"use strict";a.r(s);var e=a(15),i=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"二值状态统计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二值状态统计"}},[t._v("#")]),t._v(" 二值状态统计")]),t._v(" "),a("p",[t._v("这里的二值状态就是指集合元素的取 值就只有 0 和 1 两种。在签到打卡的场景中，我们只用记录签到(1)或未签到(0)，所 以它就是非常典型的二值状态，在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月(假设是 31 天)的签 到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂 的集合类型。这个时候，我们就可以选择 Bitmap。")]),t._v(" "),a("p",[t._v("Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。 String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用 起来，用来表示一个元素的二值状态。你可以把 Bitmap 看作是一个 bit 数组。")]),t._v(" "),a("p",[t._v("Bitmap 提供了 GETBIT/SETBIT 操作，使用一个偏移值 offset 对 bit 数组的某一个 bit 位 进行读和写。不过，需要注意的是，Bitmap 的偏移量是从 0 开始算的，也就是说 offset 的最小值是 0。当使用 SETBIT 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。 Bitmap 还提供了 BITCOUNT 操作，用来统计这个 bit 数组中所有“1”的个数。")]),t._v(" "),a("p",[t._v("假设我们要统计 ID 3000 的用户在 2020 年 8 月份的签到情况。")]),t._v(" "),a("p",[t._v("第一步，执行下面的命令，记录该用户 8 月 3 号已签到。")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("SETBIT uid:sign:3000:202008 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("第二步，检查该用户 8 月 3 日是否签到。")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" GETBIT uid:sign:3000:202008 "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("第三步，统计该用户在 8 月份的签到次数。")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("BITCOUNT uid:sign:3000:202008\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("如果记录了 1 亿个用户 10 天的签到情况，你有办法统计出这 10 天连续签到 的用户总数吗?")]),t._v(" "),a("p",[t._v("Bitmap 支持用 BITOP 命令对多个 Bitmap 按位 做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中。可以把每天的日期作为 key，每个 key 对应一个 1 亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况。")]),t._v(" "),a("p",[t._v("接下来，我们对 10 个 Bitmap 做“与”操作，得到的结果也是一个 Bitmap。在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。最后，我们可以用 BITCOUNT 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。")]),t._v(" "),a("p",[t._v("在实际应用时，最好对 Bitmap 设置过期时间，让 Redis 自动删除不再需要的签到记录，以节省内存开销。")]),t._v(" "),a("p",[a("strong",[t._v("所以，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。在记录海量数据时，Bitmap 能够有效 地节省内存空间。")])])])}),[],!1,null,null,null);s.default=i.exports}}]);