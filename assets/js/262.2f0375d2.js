(window.webpackJsonp=window.webpackJsonp||[]).push([[262],{994:function(e,r,f){"use strict";f.r(r);var a=f(15),n=Object(a.a)({},(function(){var e=this,r=e.$createElement,f=e._self._c||r;return f("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[f("h1",{attrs:{id:"什么是-change-buffer"}},[f("a",{staticClass:"header-anchor",attrs:{href:"#什么是-change-buffer"}},[e._v("#")]),e._v(" 什么是 change buffer？")]),e._v(" "),f("p",[e._v("当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。")]),e._v(" "),f("p",[e._v("将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。")]),e._v(" "),f("p",[e._v("显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。")]),e._v(" "),f("h1",{attrs:{id:"change-buffer-的使用场景"}},[f("a",{staticClass:"header-anchor",attrs:{href:"#change-buffer-的使用场景"}},[e._v("#")]),e._v(" change buffer 的使用场景")]),e._v(" "),f("p",[e._v("因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。")]),e._v(" "),f("p",[e._v("因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。")]),e._v(" "),f("p",[e._v("反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。")])])}),[],!1,null,null,null);r.default=n.exports}}]);