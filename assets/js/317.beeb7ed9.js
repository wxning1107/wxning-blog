(window.webpackJsonp=window.webpackJsonp||[]).push([[317],{1189:function(t,v,_){"use strict";_.r(v);var o=_(15),n=Object(o.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"mongodb索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mongodb索引"}},[t._v("#")]),t._v(" MongoDB索引?")]),t._v(" "),_("p",[_("strong",[t._v("MongoDB索引类型：")]),t._v(" 单字段索引、复合索引、多key索引、文本索引、哈希索引等。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("复合索引字段顺序：")]),t._v(" "),_("p",[t._v("遵循ESR规则\n对于复合索引，这个经验法则对于确定索引中字段的顺序是非常有帮助的：")]),t._v(" "),_("ul",[_("li",[t._v("首先，添加针对等值（Equality）查询的字段。")]),t._v(" "),_("li",[t._v("接下来要索引的字段应该反映出查询的排序（Sort）顺序。")]),t._v(" "),_("li",[t._v("最后要添加的字段表示要访问的数据的范围（Range）。")])])]),t._v(" "),_("p",[t._v("注意：MongoDb 3.2 之前，确实使用 B 树作为存储的数据结构，之后使用了 WiredTiger 作为其默认的存储引擎，WiredTiger索引使用B+树。")]),t._v(" "),_("p",[t._v("Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构。MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql。")]),t._v(" "),_("p",[_("strong",[t._v("第一：查找元素")])]),t._v(" "),_("p",[t._v("1.B树的数据保存在所有节点，查询复杂度最好是 O(1)。")]),t._v(" "),_("p",[t._v("2.B+树的数据保存在叶子节点，查询时间复杂度固定是O(log(n))")]),t._v(" "),_("p",[_("strong",[t._v("第二：区间查找")])]),t._v(" "),_("p",[t._v("1.B树每个节点 key 和 data 在一起，则无法区间查找。\n2.B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等")]),t._v(" "),_("p",[_("strong",[t._v("第三：存储")])]),t._v(" "),_("p",[t._v("1.B树每个节点即保存数据又保存索引，所以每一节点特别大，这一层所有节点加起来数据量将非常大。磁盘每次IO一定量的数据，对于Mysql来说如何衡量查询效率呢？就是磁盘IO次数。既然B树每一层特别大，那每一层就需要对数据分开从而进行多次IO操作。所有Mysql不用。")]),t._v(" "),_("p",[t._v("2.B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确，所以不需要用B+树。")]),t._v(" "),_("p",[_("strong",[t._v("参考：")]),t._v(" https://zhuanlan.zhihu.com/p/365909845")])])}),[],!1,null,null,null);v.default=n.exports}}]);