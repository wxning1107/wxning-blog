(window.webpackJsonp=window.webpackJsonp||[]).push([[444],{1543:function(v,_,P){"use strict";P.r(_);var t=P(15),p=Object(t.a)({},(function(){var v=this,_=v.$createElement,P=v._self._c||_;return P("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[P("h1",{attrs:{id:"tcp与udp有什么区别"}},[P("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp有什么区别"}},[v._v("#")]),v._v(" TCP与UDP有什么区别？")]),v._v(" "),P("p",[v._v("TCP 是面向连接的，UDP 是面向无连接的。")]),v._v(" "),P("p",[v._v("正因为 TCP 是面向连接的，所以 TCP 有很多特性。")]),v._v(" "),P("p",[v._v("例如，TCP 提供可靠交付。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。而 UDP 不保证不丢失，不保证按顺序到达。")]),v._v(" "),P("p",[v._v("再如，TCP 是面向字节流的。发送的时候发的是一个流，没头没尾。而 UDP 是基于数据报的，一个一个地发，一个一个地收。")]),v._v(" "),P("p",[v._v("还有TCP 是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP 就不会，应用让我发，我就发，管它洪水滔天。")]),v._v(" "),P("p",[v._v("因而TCP 其实是一个有状态服务，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而 UDP 则是无状态服务。通俗地说是没脑子的，天真无邪的，发出去就发出去了。")]),v._v(" "),P("p",[P("strong",[v._v("UDP 使用场景")])]),v._v(" "),P("p",[v._v("第一，需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。")]),v._v(" "),P("p",[v._v("第二，不需要一对一沟通，建立连接，而是可以广播的应用。")]),v._v(" "),P("p",[v._v("第三，处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩。")]),v._v(" "),P("p",[v._v("UDP 简单、处理速度快，不像 TCP 那样，操这么多的心，各种重传啊，保证顺序啊，前面的不收到，后面的没法处理啊。不然等这些事情做完了，时延早就上去了。而 TCP 在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。")]),v._v(" "),P("div",{staticClass:"custom-block tip"},[P("p",{staticClass:"custom-block-title"},[v._v("UDP 的主要特点")]),v._v(" "),P("p",[v._v("1.UDP 是无连接的；")]),v._v(" "),P("p",[v._v("2.UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态；")]),v._v(" "),P("p",[v._v("3.UDP 是面向报文的；")]),v._v(" "),P("p",[v._v("4.UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；")]),v._v(" "),P("p",[v._v("5.UDP 支持一对一、一对多、多对一和多对多的交互通信(原因是不面向连接)；")]),v._v(" "),P("p",[v._v("6.UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。")])]),v._v(" "),P("div",{staticClass:"custom-block tip"},[P("p",{staticClass:"custom-block-title"},[v._v("TCP 的主要特点")]),v._v(" "),P("p",[v._v("1.TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；")]),v._v(" "),P("p",[v._v("2.每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；")]),v._v(" "),P("p",[v._v("3.TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；")]),v._v(" "),P("p",[v._v("4.TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。")]),v._v(" "),P("p",[v._v("5.TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。")])]),v._v(" "),P("p",[P("strong",[v._v("UDP 应用举例")])]),v._v(" "),P("p",[P("strong",[v._v("1.网页或者 APP 的访问")])]),v._v(" "),P("p",[v._v("原来访问网页和手机 APP 都是基于 HTTP 协议的。HTTP 协议是基于 TCP 的，建立连接都需要多次交互，对于时延比较大的目前主流的移动互联网来讲，建立一次连接需要的时间会比较长，然而既然是移动中，TCP 可能还会断了重连，也是很耗时的。而且目前的 HTTP 协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是 TCP 的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。")]),v._v(" "),P("p",[v._v("而QUIC（全称Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。")]),v._v(" "),P("p",[v._v("QUIC 在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制。")]),v._v(" "),P("p",[P("strong",[v._v("2.流媒体的协议")])]),v._v(" "),P("p",[v._v("现在直播比较火，直播协议多使用 RTMP，这个协议我们后面的章节也会讲，而这个 RTMP 协议也是基于 TCP 的。TCP 的严格顺序传输要保证前一个收到了，下一个才能确认，如果前一个收不到，下一个就算包已经收到了，在缓存里面，也需要等着。对于直播来讲，这显然是不合适的，因为老的视频帧丢了其实也就丢了，就算再传过来用户也不在意了，他们要看新的了，如果老是没来就等着，卡顿了，新的也看不了，那就会丢失客户，所以直播，实时性比较比较重要，宁可丢包，也不要卡顿的。")]),v._v(" "),P("p",[v._v("还有就是当网络不好的时候，TCP 协议会主动降低发送速度，这对本来当时就卡的看视频来讲是要命的，应该应用层马上重传，而不是主动让步。因而，很多直播应用，都基于 UDP 实现了自己的视频传输协议。")]),v._v(" "),P("p",[P("strong",[v._v("3.实时游戏")])]),v._v(" "),P("p",[v._v("游戏有一个特点，就是实时性比较高。实时游戏中客户端和服务端要建立长连接，来保证实时传输。但是游戏玩家很多，服务器却不多。由于维护 TCP 连接需要在内核维护一些数据结构，因而一台机器能够支撑的 TCP 连接数目是有限的，然后 UDP 由于是没有连接的，在异步 IO 机制引入之前，常常是应对海量客户端连接的策略。")]),v._v(" "),P("p",[v._v("另外还是 TCP 的强顺序问题，对战的游戏，对网络的要求很简单，玩家通过客户端发送给服务器鼠标和键盘行走的位置，服务器会处理每个用户发送过来的所有场景，处理完再返回给客户端，客户端解析响应，渲染最新的场景展示给玩家。")]),v._v(" "),P("p",[v._v("如果出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据，然而玩家并不关心过期的数据，激战中卡 1 秒，等能动了都已经死了。")]),v._v(" "),P("p",[v._v("游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。")])])}),[],!1,null,null,null);_.default=p.exports}}]);