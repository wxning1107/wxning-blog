(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{411:function(t,a,_){t.exports=_.p+"assets/img/image-20220306182354471.59acd8e9.png"},412:function(t,a,_){t.exports=_.p+"assets/img/image-20220306182708139.ee5dbc72.png"},814:function(t,a,_){"use strict";_.r(a);var e=_(15),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"order-by-底层原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#order-by-底层原理"}},[t._v("#")]),t._v(" order by 底层原理？")]),t._v(" "),e("p",[t._v("假设你要查询城市是“杭州”的所有人名字，并且按照姓名排序返回前 1000 个人的姓名、年龄。")]),t._v(" "),e("div",{staticClass:"language-mysql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("CREATE TABLE `t` (\n  `id` int(11) NOT NULL,\n  `city` varchar(16) NOT NULL,\n  `name` varchar(16) NOT NULL,\n  `age` int(11) NOT NULL,\n  `addr` varchar(128) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `city` (`city`)\n) ENGINE=InnoDB;\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("p",[t._v("SQL 语句可以这么写：")]),t._v(" "),e("div",{staticClass:"language-mysql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("select city,name,age from t where city='杭州' order by name limit 1000;\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h1",{attrs:{id:"全字段排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全字段排序"}},[t._v("#")]),t._v(" 全字段排序")]),t._v(" "),e("p",[t._v("为避免全表扫描，我们需要在 city 字段加上索引。")]),t._v(" "),e("p",[e("img",{attrs:{src:_(411),alt:"img"}})]),t._v(" "),e("p",[t._v("Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。")]),t._v(" "),e("p",[e("img",{attrs:{src:_(412),alt:"img"}})]),t._v(" "),e("p",[t._v("通常情况下，这个语句执行流程如下所示 ：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("1.初始化 sort_buffer，确定放入 name、city、age 这三个字段；")])]),t._v(" "),e("li",[e("p",[t._v("2.从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；")])]),t._v(" "),e("li",[e("p",[t._v("3.到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；")])]),t._v(" "),e("li",[e("p",[t._v("4.从索引 city 取下一个记录的主键 id；")])]),t._v(" "),e("li",[e("p",[t._v("5.重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；")])]),t._v(" "),e("li",[e("p",[t._v("6.对 sort_buffer 中的数据按照字段 name 做快速排序；")])]),t._v(" "),e("li",[e("p",[t._v("7.按照排序结果取前 1000 行返回给客户端。")])])]),t._v(" "),e("p",[t._v("“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。")]),t._v(" "),e("p",[t._v("外部排序一般使用归并排序算法。可以这么简单理解，MySQL 将需要排序的数据分成 12 份，每一份单独排序后存在这些临时文件中。然后把这 12 个有序文件再合并成一个有序的大文件。")]),t._v(" "),e("h1",{attrs:{id:"rowid-排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rowid-排序"}},[t._v("#")]),t._v(" rowid 排序")]),t._v(" "),e("p",[t._v("在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。")]),t._v(" "),e("p",[t._v("那么，如果 MySQL 认为排序的单行长度太大会怎么做呢？")]),t._v(" "),e("p",[t._v("max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。")]),t._v(" "),e("p",[t._v("city、name、age 这三个字段的定义总长度是 36，我把 max_length_for_sort_data 设置为 16。新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。")]),t._v(" "),e("p",[t._v("但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("1.初始化 sort_buffer，确定放入两个字段，即 name 和 id；")])]),t._v(" "),e("li",[e("p",[t._v("2.从索引 city 找到第一个满足 city='杭州’条件的主键 id，也就是图中的 ID_X；")])]),t._v(" "),e("li",[e("p",[t._v("3.到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；")])]),t._v(" "),e("li",[e("p",[t._v("4.从索引 city 取下一个记录的主键 id；")])]),t._v(" "),e("li",[e("p",[t._v("5.重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y；")])]),t._v(" "),e("li",[e("p",[t._v("6.对 sort_buffer 中的数据按照字段 name 进行排序；")])]),t._v(" "),e("li",[e("p",[t._v("7.遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。")])])]),t._v(" "),e("p",[t._v("我把它称为 rowid 排序。rowid 排序多访问了一次表 t 的主键索引，就是步骤 7。")]),t._v(" "),e("h1",{attrs:{id:"全字段排序-vs-rowid-排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全字段排序-vs-rowid-排序"}},[t._v("#")]),t._v(" 全字段排序 VS rowid 排序")]),t._v(" "),e("p",[t._v("如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。")]),t._v(" "),e("p",[t._v("如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。")]),t._v(" "),e("p",[t._v("这也就体现了 MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。")]),t._v(" "),e("p",[t._v("其实，并不是所有的 order by 语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无序的。")]),t._v(" "),e("p",[t._v("你可以设想下，如果能够保证从 city 这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢？")]),t._v(" "),e("p",[t._v("确实是这样的。")]),t._v(" "),e("p",[t._v("所以，我们可以在这个市民表上创建一个 city 和 name 的联合索引。")]),t._v(" "),e("p",[t._v("在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足 city='杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是杭州，name 的值就一定是有序的。")]),t._v(" "),e("p",[t._v("这样整个查询过程的流程就变成了：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("1.从索引 (city,name) 找到第一个满足 city='杭州’条件的主键 id；")])]),t._v(" "),e("li",[e("p",[t._v("2.到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；")])]),t._v(" "),e("li",[e("p",[t._v("3.从索引 (city,name) 取下一个记录主键 id；")])]),t._v(" "),e("li",[e("p",[t._v("4.重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city='杭州’条件时循环结束。")])])]),t._v(" "),e("p",[t._v("这个语句的执行流程可以进一步优化，我们可以创建一个 city、name 和 age 的联合索引，让该语句使用覆盖索引，这样可以省略第二步。")])])}),[],!1,null,null,null);a.default=i.exports}}]);