(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{432:function(v,e,t){v.exports=t.p+"assets/img/image-20220310184325114.67fbe35c.png"},433:function(v,e,t){v.exports=t.p+"assets/img/image-20220310184809567.5342decb.png"},825:function(v,e,t){"use strict";t.r(e);var s=t(15),_=Object(s.a)({},(function(){var v=this,e=v.$createElement,s=v._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h1",{attrs:{id:"redis-持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化"}},[v._v("#")]),v._v(" Redis 持久化？")]),v._v(" "),s("h1",{attrs:{id:"aof日志"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof日志"}},[v._v("#")]),v._v(" AOF日志")]),v._v(" "),s("p",[v._v("说到日志，我们比较熟悉的是数据库的写前日志(Write Ahead Log, WAL)，也就是 说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过， AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入 内存，然后才记录日志")]),v._v(" "),s("p",[v._v("那 AOF 为什么要先执行命令再记日志呢?")]),v._v(" "),s("p",[v._v("传统数据库的日志，例如 redo log(重做日志)，记录的是修改后的数据，而 AOF 里记 录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。")]),v._v(" "),s("p",[v._v("我们以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内 容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着 具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例 如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。")]),v._v(" "),s("p",[s("img",{attrs:{src:t(432),alt:"img"}})]),v._v(" "),s("p",[v._v("但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这 些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误 的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志 中，否则，系统就会直接向客户端报错。")]),v._v(" "),s("p",[v._v("除此之外，AOF 还有一个好处:它是在命令执行后才记录日志，所以不会阻塞当前的写操作。")]),v._v(" "),s("p",[v._v("不过，AOF 也有两个潜在的风险。")]),v._v(" "),s("ul",[s("li",[v._v("首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数 据就有丢失的风险。")]),v._v(" "),s("li",[v._v("其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因 为，AOF 日志也是在主线程中执行的。")])]),v._v(" "),s("p",[v._v("这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味 着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。")]),v._v(" "),s("h1",{attrs:{id:"三种写回策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三种写回策略"}},[v._v("#")]),v._v(" 三种写回策略")]),v._v(" "),s("p",[v._v("AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值。")]),v._v(" "),s("ul",[s("li",[v._v("Always，同步写回:每个写命令执行完，立马同步地将日志写回磁盘;")]),v._v(" "),s("li",[v._v("Everysec，每秒写回:每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘;")]),v._v(" "),s("li",[v._v("No，操作系统控制的写回:每个写命令执行完，只是先把日志写到 AOF 文件的内存缓 冲区，由操作系统决定何时将缓冲区内容写回磁盘。")])]),v._v(" "),s("p",[s("img",{attrs:{src:t(433),alt:"img"}})]),v._v(" "),s("h1",{attrs:{id:"aof-重写机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写机制"}},[v._v("#")]),v._v(" AOF 重写机制")]),v._v(" "),s("p",[v._v("简单来说，AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文 件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写 入。比如说，当读取了键值对“testkey”: “testvalue”之后，重写机制会记录 set testkey testvalue 这条命令。这样，当需要恢复时，可以重新执行该命令，实 现“testkey”: “testvalue”的写入。")]),v._v(" "),s("p",[v._v("AOF 重写后，日志文件会缩小，而且，和 AOF 日志由主线程写回不同，重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。")]),v._v(" "),s("p",[v._v("我把重写的过程总结为“一个拷贝，两处日志”。")]),v._v(" "),s("p",[v._v("“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此 时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的 最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数 据写成操作，记入重写日志。")]),v._v(" "),s("p",[v._v("因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指 正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这 个 AOF 日志的操作仍然是齐全的，可以用于恢复。")]),v._v(" "),s("p",[v._v("而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这 样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日 志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我 们就可以用新的 AOF 文件替代旧文件了。")]),v._v(" "),s("h1",{attrs:{id:"rdb-内存快照"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb-内存快照"}},[v._v("#")]),v._v(" RDB 内存快照")]),v._v(" "),s("p",[v._v("和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我 们可以直接把 RDB 文件读入内存，很快地完成恢复。它执行的是全量快照，也就 是说，把内存中的所有数据都记录到磁盘中")]),v._v(" "),s("p",[v._v("我们就可以通过 bgsave 命令来执行全量快照，bgsave 创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞。")]),v._v(" "),s("p",[v._v("如果快照执行期间数据不能被修改，是会有潜在问题的。所以这个时候，Redis 就会借助操作系统提 供的写时复制技术(Copy-On-Write, COW)，在执行快照的同时，正常处理写操作。")]),v._v(" "),s("p",[v._v("简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。 bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。")]),v._v(" "),s("p",[v._v("此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据， 那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本 数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。")]),v._v(" "),s("p",[v._v("如果频繁地执行全量快照，也会带来两方面的开销。")]),v._v(" "),s("ul",[s("li",[v._v("一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。")]),v._v(" "),s("li",[v._v("另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后 不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越 大，阻塞时间越长。")])]),v._v(" "),s("p",[v._v("我们可以做增量快照，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。")]),v._v(" "),s("p",[v._v("虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销，那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做 到尽量少丢数据呢?")]),v._v(" "),s("p",[s("strong",[v._v("Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一 定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。")])]),v._v(" "),s("p",[v._v("这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出 现文件过大的情况了，也可以避免重写开销。")])])}),[],!1,null,null,null);e.default=_.exports}}]);