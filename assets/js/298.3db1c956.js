(window.webpackJsonp=window.webpackJsonp||[]).push([[298],{1076:function(t,v,_){"use strict";_.r(v);var n=_(15),s=Object(n.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"应用场景的局限性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用场景的局限性"}},[t._v("#")]),t._v(" 应用场景的局限性")]),t._v(" "),_("p",[_("strong",[t._v("首先，二分查找依赖的是顺序表结构，简单点说就是数组。")])]),t._v(" "),_("p",[t._v("那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。我们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。")]),t._v(" "),_("p",[_("strong",[t._v("其次，二分查找针对的是有序数据。")])]),t._v(" "),_("p",[t._v("二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。")]),t._v(" "),_("p",[t._v("如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢？别急，等到二叉树那一节我会详细讲。")]),t._v(" "),_("p",[_("strong",[t._v("再次，数据量太小不适合二分查找。")])]),t._v(" "),_("p",[t._v("如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。只有数据量比较大的时候，二分查找的优势才会比较明显。")]),t._v(" "),_("p",[t._v("不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。")]),t._v(" "),_("p",[_("strong",[t._v("最后，数据量太大也不适合二分查找。")])]),t._v(" "),_("p",[t._v("二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。")])])}),[],!1,null,null,null);v.default=s.exports}}]);