(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{449:function(v,_,t){v.exports=t.p+"assets/img/image-20211103220153542.d31a8adb.png"},750:function(v,_,t){"use strict";t.r(_);var n=t(15),s=Object(n.a)({},(function(){var v=this,_=v.$createElement,n=v._self._c||_;return n("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[n("h1",{attrs:{id:"散列表-链表案例一-lru-缓存淘汰算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#散列表-链表案例一-lru-缓存淘汰算法"}},[v._v("#")]),v._v(" 散列表-链表案例一：LRU 缓存淘汰算法")]),v._v(" "),n("p",[v._v("首先，我们来回顾一下当时我们是如何通过链表实现 LRU 缓存淘汰算法的。")]),v._v(" "),n("p",[v._v("我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。")]),v._v(" "),n("p",[v._v("当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。")]),v._v(" "),n("p",[v._v("实际上，我总结一下，一个缓存（cache）系统主要包含下面这几个操作：")]),v._v(" "),n("ul",[n("li",[v._v("往缓存中添加一个数据；")]),v._v(" "),n("li",[v._v("从缓存中删除一个数据；")]),v._v(" "),n("li",[v._v("在缓存中查找一个数据。")])]),v._v(" "),n("p",[v._v("这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。具体的结构就是下面这个样子：")]),v._v(" "),n("p",[n("img",{attrs:{src:t(449),alt:"img"}})]),v._v(" "),n("p",[v._v("我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。这个 hnext 有什么作用呢？")]),v._v(" "),n("p",[v._v("因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的"),n("strong",[v._v("双向链表")]),v._v("，另一个链是散列表中的"),n("strong",[v._v("拉链")]),v._v("。"),n("strong",[v._v("前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中")]),v._v("。")]),v._v(" "),n("p",[v._v("我们再来看，前面讲到的缓存的三个操作，是如何做到时间复杂度是 O(1) 的？")]),v._v(" "),n("p",[v._v("首先，我们来看"),n("strong",[v._v("如何查找一个数据")]),v._v("。我们前面讲过，散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。")]),v._v(" "),n("p",[v._v("其次，我们来看"),n("strong",[v._v("如何删除一个数据")]),v._v("。我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。")]),v._v(" "),n("p",[v._v("最后，我们来看"),n("strong",[v._v("如何添加一个数据")]),v._v("。添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。")]),v._v(" "),n("p",[v._v("这整个过程涉及的查找操作都可以通过散列表来完成。其他的操作，比如删除头结点、链表尾部插入数据等，都可以在 O(1) 的时间复杂度内完成。所以，这三个操作的时间复杂度都是 O(1)。至此，我们就通过散列表和双向链表的组合使用，实现了一个高效的、支持 LRU 缓存淘汰算法的缓存系统原型。")])])}),[],!1,null,null,null);_.default=s.exports}}]);