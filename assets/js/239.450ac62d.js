(window.webpackJsonp=window.webpackJsonp||[]).push([[239],{941:function(t,e,s){"use strict";s.r(e);var v=s(15),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"为什么redis要用跳表来实现有序集合-而不是红黑树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么redis要用跳表来实现有序集合-而不是红黑树"}},[t._v("#")]),t._v(" 为什么Redis要用跳表来实现有序集合，而不是红黑树？")]),t._v(" "),s("p",[t._v("Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：")]),t._v(" "),s("ul",[s("li",[t._v("插入一个数据；")]),t._v(" "),s("li",[t._v("删除一个数据；")]),t._v(" "),s("li",[t._v("查找一个数据；")]),t._v(" "),s("li",[t._v("按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；")]),t._v(" "),s("li",[t._v("迭代输出有序序列。")])]),t._v(" "),s("p",[t._v("其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，"),s("strong",[t._v("按照区间来查找数据这个操作，红黑树的效率没有跳表高。")])]),t._v(" "),s("p",[t._v("对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。")]),t._v(" "),s("p",[t._v("当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。")]),t._v(" "),s("p",[t._v("不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。")])])}),[],!1,null,null,null);e.default=_.exports}}]);