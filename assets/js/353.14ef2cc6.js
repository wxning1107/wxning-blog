(window.webpackJsonp=window.webpackJsonp||[]).push([[353],{1216:function(t,s,a){"use strict";a.r(s);var e=a(15),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"缓存雪崩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[t._v("#")]),t._v(" 缓存雪崩")]),t._v(" "),a("p",[t._v("缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。")]),t._v(" "),a("p",[t._v("通常是由于缓存中有大量数据同时过期，此时，应用再访问这些数据的话，就会发生缓存缺失。紧接着，应用就会把请求发送给数据库，从数据库中读取数据。数据库的压力就会很大。")]),t._v(" "),a("h1",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),a("p",[t._v("有两种解决方案：")]),t._v(" "),a("p",[t._v("首先，我们可以避免给大量的数据设置相同的过期时间。如果业务层的确要求有些数据同时失效，你可以在用 EXPIRE 命令给每个数据设置过期时间时，给这些数据的过期时间增加一个较小的随机数（例如，随机增加 1~3 分钟）")]),t._v(" "),a("p",[t._v("还可以通过服务降级，来应对缓存雪崩。")]),t._v(" "),a("p",[t._v("当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；")]),t._v(" "),a("p",[t._v("当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。")]),t._v(" "),a("p",[t._v("这样一来，只有部分过期数据的请求会发送到数据库，数据库的压力就没有那么大了。")])])}),[],!1,null,null,null);s.default=v.exports}}]);