(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{1184:function(v,_,a){"use strict";a.r(_);var s=a(15),t=Object(s.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h1",{attrs:{id:"索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[v._v("#")]),v._v(" 索引")]),v._v(" "),s("h1",{attrs:{id:"innodb-的索引模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#innodb-的索引模型"}},[v._v("#")]),v._v(" InnoDB 的索引模型")]),v._v(" "),s("p",[v._v("在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。")]),v._v(" "),s("p",[v._v("根据叶子节点的内容，索引类型分为主键索引和非主键索引。")]),v._v(" "),s("p",[v._v("主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。")]),v._v(" "),s("p",[v._v("非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。")]),v._v(" "),s("h1",{attrs:{id:"索引维护"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引维护"}},[v._v("#")]),v._v(" 索引维护")]),v._v(" "),s("p",[v._v("B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。新插入数据时可能会导致挪动后面的数据，而更糟的情况是，如果所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。")]),v._v(" "),s("p",[v._v("除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。")]),v._v(" "),s("h1",{attrs:{id:"为什么推荐使用自增主键"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么推荐使用自增主键"}},[v._v("#")]),v._v(" 为什么推荐使用自增主键？")]),v._v(" "),s("p",[v._v("自增主键的插入数据模式，符合递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。")]),v._v(" "),s("p",[v._v("除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？")]),v._v(" "),s("p",[v._v("由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。")]),v._v(" "),s("p",[s("strong",[v._v("显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。")])]),v._v(" "),s("p",[v._v("所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。")]),v._v(" "),s("p",[v._v("有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：")]),v._v(" "),s("ul",[s("li",[s("p",[v._v("只有一个索引；")])]),v._v(" "),s("li",[s("p",[v._v("该索引必须是唯一索引。")])])]),v._v(" "),s("p",[v._v("你一定看出来了，这就是典型的 KV 场景。")]),v._v(" "),s("p",[v._v("由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。")]),v._v(" "),s("h1",{attrs:{id:"覆盖索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[v._v("#")]),v._v(" 覆盖索引")]),v._v(" "),s("p",[v._v("如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。")]),v._v(" "),s("p",[s("strong",[v._v("由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。")])]),v._v(" "),s("h1",{attrs:{id:"最左前缀原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最左前缀原则"}},[v._v("#")]),v._v(" 最左前缀原则")]),v._v(" "),s("p",[v._v("B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。")]),v._v(" "),s("h1",{attrs:{id:"在建立联合索引的时候-如何安排索引内的字段顺序。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在建立联合索引的时候-如何安排索引内的字段顺序。"}},[v._v("#")]),v._v(" 在建立联合索引的时候，如何安排索引内的字段顺序。")]),v._v(" "),s("p",[v._v("这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。")]),v._v(" "),s("p",[v._v("那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。")]),v._v(" "),s("p",[v._v("这时候，我们要考虑的原则就是空间了。比如 name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("提示")]),v._v(" "),s("p",[v._v("联合索引与where条件的顺序无关，where a=1 and b=2 和 where b=2 and a=1都会使用（a,b）联合索引。")])]),v._v(" "),s("h1",{attrs:{id:"索引下推"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引下推"}},[v._v("#")]),v._v(" 索引下推")]),v._v(" "),s("p",[v._v("我们以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：")]),v._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("select * from tuser where name like '张 %' and age=10 and ismale=1;\n")])]),v._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[v._v("1")]),s("br")])]),s("p",[v._v("你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。")]),v._v(" "),s("p",[v._v("然后呢？")]),v._v(" "),s("p",[v._v("当然是判断其他条件是否满足。")]),v._v(" "),s("p",[v._v("在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。即，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。")]),v._v(" "),s("p",[v._v("而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。减少回表次数。")]),v._v(" "),s("h1",{attrs:{id:"索引失效场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引失效场景"}},[v._v("#")]),v._v(" 索引失效场景")]),v._v(" "),s("p",[s("font",{attrs:{size:"5"}},[s("strong",[v._v("条件字段函数操作")])])],1),v._v(" "),s("p",[v._v("例如：统计发生在所有年份中 7 月份的交易记录总数")]),v._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("mysql> select count(*) from tradelog where month(t_modified)=7;\n")])]),v._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[v._v("1")]),s("br")])]),s("p",[s("font",{attrs:{size:"5"}},[s("strong",[v._v("隐式类型转换")])])],1),v._v(" "),s("p",[v._v("tradeid 的字段类型是 varchar(32)，而输入的参数却是整型，所以需要做类型转换:")]),v._v(" "),s("div",{staticClass:"language-mysql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("mysql> select * from tradelog where tradeid=110717;\n")])]),v._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[v._v("1")]),s("br")])]),s("p",[s("font",{attrs:{size:"5"}},[s("strong",[v._v("隐式字符编码转换")])])],1),v._v(" "),s("p",[v._v("utf8mb4 与 utf8 字符集转换")]),v._v(" "),s("p",[s("font",{attrs:{size:"5"}},[s("strong",[v._v("其他索引失效场景")])])],1),v._v(" "),s("p",[s("img",{attrs:{src:a(507),alt:"img"}})]),v._v(" "),s("h1",{attrs:{id:"什么时候不适合建索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么时候不适合建索引"}},[v._v("#")]),v._v(" 什么时候不适合建索引?")]),v._v(" "),s("p",[s("strong",[v._v("哪些情况下不适合建索引?")])]),v._v(" "),s("ul",[s("li",[s("p",[v._v("经常增删改的表的字段不适合建立索引")])]),v._v(" "),s("li",[s("p",[v._v("表记录太少")])]),v._v(" "),s("li",[s("p",[v._v("where条件中用不到的字段不适合建立索引")])]),v._v(" "),s("li",[s("p",[v._v("表数据可以确定比较少的不需要建索引")])]),v._v(" "),s("li",[s("p",[v._v("数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值")])]),v._v(" "),s("li",[s("p",[v._v("参与列计算的列不适合建索引")])])]),v._v(" "),s("p",[s("br"),s("br")]),v._v(" "),s("p",[s("strong",[v._v("哪些情况下适合建索引?")])]),v._v(" "),s("ul",[s("li",[s("p",[v._v("主键自动建立唯一索引。")])]),v._v(" "),s("li",[s("p",[v._v("频繁作为where条件语句查询的字段")])]),v._v(" "),s("li",[s("p",[v._v("关联字段需要建立索引，例如外键字段，student表中的classid,   classes表中的schoolid 等")])]),v._v(" "),s("li",[s("p",[v._v("排序字段可以建立索引")])]),v._v(" "),s("li",[s("p",[v._v("分组字段可以建立索引，因为分组的前提是排序")])]),v._v(" "),s("li",[s("p",[v._v("统计字段可以建立索引，例如count(),max()")])])]),v._v(" "),s("hr"),v._v(" "),s("p",[v._v("索引设计原则：")]),v._v(" "),s("p",[v._v("1、适合索引的列是出现在where字句中的列，或者连接子句中指定的列")]),v._v(" "),s("p",[v._v("2、基数较小的表（比如性别，基数只有男，女），索引效果差，没必要创建索引")]),v._v(" "),s("p",[v._v("3、在选择索引列的时候，越短越好，可以指定某些列的一部分，没必要用全部字段的值")]),v._v(" "),s("p",[v._v("4、不要给表中的每一个字段都创建索引，并不是索引越多越好")]),v._v(" "),s("p",[v._v("5、定义有外键的数据列一定要创建索引")]),v._v(" "),s("p",[v._v("6、更新频繁的字段不要有索引")]),v._v(" "),s("p",[v._v("7、创建索引的列不要过多，可以创建组合索引，但是组合索引的列的个数不建议太多")]),v._v(" "),s("p",[v._v("8、大文本、大对象不要创建索引")]),v._v(" "),s("h1",{attrs:{id:"聚簇索引和非聚簇索引区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引和非聚簇索引区别"}},[v._v("#")]),v._v(" 聚簇索引和非聚簇索引区别?")]),v._v(" "),s("p",[v._v("聚簇索引是将数据存储与索引放到了一起，非聚簇索引是将数据与索引分开存储，MyIsam 的B+树的叶子节点记录的是真实数据的存储地址。")]),v._v(" "),s("p",[s("img",{attrs:{src:a(508),alt:"img"}})]),v._v(" "),s("p",[s("img",{attrs:{src:a(509),alt:"img"}})]),v._v(" "),s("p",[v._v("mysql的索引类型跟存储引擎是相关的，innodb存储引擎数据文件跟索引文件全部放在ibd文件中，而myisam的数据文件放在myd文件中，索引放在myi文件中，其实区分聚簇索引和非聚簇索引非常简单，只要判断数据跟索引是否存储在一起就可以了。")]),v._v(" "),s("p",[v._v("innodb存储引擎在进行数据插入的时候，数据必须要跟索引放在一起，如果有主键就使用主键，没有主键就使用唯一键，没有唯一键就使用6字节的rowid，因此跟数据绑定在一起的就是聚簇索引，而为了避免数据冗余存储，其他的索引的叶子节点中存储的都是聚簇索引的key值，"),s("strong",[v._v("因此innodb中既有聚簇索引也有非聚簇索引，而myisam中只有非聚簇索引。")])]),v._v(" "),s("p",[s("strong",[v._v("参考：")]),v._v(" https://cloud.tencent.com/developer/article/1541265")]),v._v(" "),s("h1",{attrs:{id:"索引为什么不使用其他数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引为什么不使用其他数据结构"}},[v._v("#")]),v._v(" 索引为什么不使用其他数据结构？")]),v._v(" "),s("p",[s("strong",[v._v("哈希表这种结构适用于只有等值查询的场景")]),v._v("，比如 Memcached 及其他一些 NoSQL 引擎。哈希表不适用于区间查询。")]),v._v(" "),s("p",[v._v("虽然"),s("strong",[v._v("有序数组在等值查询和范围查询场景中的性能就都非常优秀")]),v._v("，但是在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，"),s("strong",[v._v("有序数组索引只适用于静态存储引擎")]),v._v("，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。")]),v._v(" "),s("p",[v._v("二叉树会随着数据的增加树高越来越高，查询效率也越来越低。而且范围查询效率也很低，需要回旋查找。")]),v._v(" "),s("p",[v._v("同样b树虽然解决了二叉树树高越来越高的问题，但是在返回查找时还是需要回旋查找。")]),v._v(" "),s("p",[v._v("以 InnoDB 的一个整数字段索引为例，这个 N 叉树的 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。")]),v._v(" "),s("p",[s("img",{attrs:{src:a(510),alt:"img"}})]),v._v(" "),s("p",[v._v("b+树叶子结点有指针相连接，范围查找直接通过指针找到下一个元素，叶子结点已经排好序了。")]),v._v(" "),s("p",[s("img",{attrs:{src:a(511),alt:"img"}})]),v._v(" "),s("p",[v._v("B+树与B树的不同：")]),v._v(" "),s("ul",[s("li",[s("p",[v._v("B+树非叶子节点不存在数据只存索引，B树非叶子节点存储数据")])]),v._v(" "),s("li",[s("p",[v._v("B+树查询效率更高。B+树使用双向链表串连所有叶子节点，区间查询效率更高（因为所有数据都在B+树的叶子节点，扫描数据库 只需扫一遍叶子结点就行了），但是B树则需要通过中序遍历才能完成查询范围的查找。")])]),v._v(" "),s("li",[s("p",[v._v("B+树查询效率更稳定。B+树每次都必须查询到叶子节点才能找到数据，而B树查询的数据可能不在叶子节点，也可能在，这样就会造成查询的效率的不稳定")])]),v._v(" "),s("li",[s("p",[v._v("B+树的磁盘读写代价更小。B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，通常B+树矮更胖，高度小查询产生的I/O更少。")])])]),v._v(" "),s("p",[s("strong",[v._v("参考：")]),v._v(" https://www.bilibili.com/video/BV1t5411u7Fg?p=2")]),v._v(" "),s("h1",{attrs:{id:"mysql索引数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引数据结构"}},[v._v("#")]),v._v(" mysql索引数据结构")]),v._v(" "),s("p",[v._v("MySQL 主要用到两种结构：B+ Tree 索引和 Hash 索引。")]),v._v(" "),s("p",[v._v("Inodb 存储引擎 默认是 B+Tree索引。Memory 存储引擎 默认 Hash索引。")]),v._v(" "),s("p",[v._v("MySQL 中，只有 Memory(Memory 表只存在内存中，断电会消失，适用于临时表)存储引擎显示支持 Hash 索引，是 Memory 表的默认索引类型，尽管 Memory 表也可以使用 B+Tree 索引。Hash 索引把数据以 hash 形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为 hash 结构，每个键只对应一个值，而且是散列的方式分布。所以它并不支持范围查找和排序等功能。")]),v._v(" "),s("p",[v._v("B+Tree 是 mysql 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎模式的索引类型。相对 Hash 索引，B+Tree 在查找单条记录的速度比不上 Hash 索引，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。")]),v._v(" "),s("p",[v._v("对比：")]),v._v(" "),s("p",[v._v("hash类型的索引：查询单条快，范围查询慢。")]),v._v(" "),s("p",[v._v("btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）。")]),v._v(" "),s("h1",{attrs:{id:"mysql中索引类型有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql中索引类型有哪些"}},[v._v("#")]),v._v(" mysql中索引类型有哪些？")]),v._v(" "),s("p",[v._v("普通索引：允许被索引的数据列包含重复的值")]),v._v(" "),s("p",[v._v("唯一索引：可以保证数据记录的唯一性")]),v._v(" "),s("p",[v._v("主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字primary key来创建")]),v._v(" "),s("p",[v._v("联合索引：索引可以覆盖多个数据列")]),v._v(" "),s("p",[v._v("全文索引：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术")])])}),[],!1,null,null,null);_.default=t.exports},507:function(v,_,a){v.exports=a.p+"assets/img/image-20220313201542668.a145215b.png"},508:function(v,_,a){v.exports=a.p+"assets/img/image-20220227130938278.5b772f2c.png"},509:function(v,_,a){v.exports=a.p+"assets/img/image-20220227130954259.1cd269f7.png"},510:function(v,_,a){v.exports=a.p+"assets/img/image-20220227112218602.7609c2d9.png"},511:function(v,_,a){v.exports=a.p+"assets/img/image-20220227112246500.fef4fef9.png"}}]);