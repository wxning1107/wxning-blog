(window.webpackJsonp=window.webpackJsonp||[]).push([[431],{1473:function(p,t,u){"use strict";u.r(t);var c=u(15),s=Object(c.a)({},(function(){var p=this,t=p.$createElement,u=p._self._c||t;return u("ContentSlotsDistributor",{attrs:{"slot-key":p.$parent.slotKey}},[u("h1",{attrs:{id:"cpu飙高怎么排查"}},[u("a",{staticClass:"header-anchor",attrs:{href:"#cpu飙高怎么排查"}},[p._v("#")]),p._v(" cpu飙高怎么排查？")]),p._v(" "),u("p",[p._v("cpu最小执行单元是线程，导致cpu飙高的原因有几个方面：")]),p._v(" "),u("ul",[u("li",[u("p",[p._v("cpu上下文切换过多，上下文切换主要两个方面，第一需要保存线程的运行状态，第二，让处于等待中的线程恢复执行。这两个过程需要cpu执行内核指令实现状态的保存和恢复，如果较多的上下文切换会占据大量cpu资源。像文件io，网络io，锁等待这些都会造成线程阻塞，而线程阻塞就会导致cpu上下文切换")])]),p._v(" "),u("li",[u("p",[p._v("cpu资源过度消耗，也就是在程序员创建了大量的线程，或者有线程一直占用cpu资源（比如死循环）")])])]),p._v(" "),u("p",[p._v("我们可以根据top命令找到cpu利用率过高的进程，再通过"),u("code",[p._v("shift+H")]),p._v("找到进程中cpu消耗过高的线程，这里有两种情况：")]),p._v(" "),u("ul",[u("li",[u("p",[p._v("第一种情况：cpu利用率过高的线程一直都是同一个，也就是线程id没有变化，说明，程序中存在长期占用cpu没有释放的情况，可以通过jstack工具或者线程的dump日志，定位到线程日志后找到问题代码")])]),p._v(" "),u("li",[u("p",[p._v("第二种情况：cpu利用率过高的线程id一直在变化，说明线程创建过多，需要挑选几个线程id通过jstack去线程dump中进行排查，有可能定位结果是程序正常，只是cpu飙高的那一刻用户访问量大，那我们应该采取增加系统资源的手段。")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);