(window.webpackJsonp=window.webpackJsonp||[]).push([[449],{1550:function(e,t,_){"use strict";_.r(t);var v=_(15),r=Object(v.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"简述-tcp-半连接发生场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简述-tcp-半连接发生场景"}},[e._v("#")]),e._v(" 简述 TCP 半连接发生场景")]),e._v(" "),_("p",[e._v("在 TCP 三次握手的过程中，Linux 内核会维护两个队列，分别是：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("半连接队列 (SYN Queue)")])]),e._v(" "),_("li",[_("p",[e._v("全连接队列 (Accept Queue)")])])]),e._v(" "),_("p",[e._v("正常的 TCP 三次握手过程：")]),e._v(" "),_("p",[e._v("1、Client 端向 Server 端发送 SYN 发起握手，Client 端进入 SYN_SENT 状态")]),e._v(" "),_("p",[e._v("2、Server 端收到 Client 端的 SYN 请求后，Server 端进入 SYN_RECV 状态，此时内核会将连接存储到半连接队列(SYN Queue)，并向 Client 端回复 SYN+ACK")]),e._v(" "),_("p",[e._v("3、Client 端收到 Server 端的 SYN+ACK 后，Client 端回复 ACK 并进入 ESTABLISHED 状态")]),e._v(" "),_("p",[e._v("4、Server 端收到 Client 端的 ACK 后，内核将连接从半连接队列(SYN Queue)中取出，添加到全连接队列(Accept Queue)，Server 端进入 ESTABLISHED 状态")]),e._v(" "),_("p",[e._v("5、Server 端应用进程调用 accept 函数时，将连接从全连接队列(Accept Queue)中取出")]),e._v(" "),_("p",[e._v("半连接队列和全连接队列都有长度大小限制，超过限制时内核会将连接 Drop 丢弃或者返回 RST 包。")]),e._v(" "),_("p",[_("font",{attrs:{size:"5"}},[_("strong",[e._v("半连接攻击")])])],1),e._v(" "),_("p",[e._v("在正常情况下，客户端连接服务端需要通过三次握手，首先客户端构造一个SYN连接数据包发送至服务端，自身进入SYN_SEND状态，当服务端收到客户端的SYN包之后，为其分配内存核心内存，并将其放置在半连接队列中，服务端接收客户SYN包并会向客户端发送一个SYN包和ACK包，此刻服务端进入SYN_RECV态。客户端收到包之后，再次向服务端发送ACK确认包。至此连接建立完成，双方都进入ESTABLSHEDZ状态。半连接就是通过不断地构造客户端的SYN连接数据包发向服务端，等到服务端的半连接队列满的时候，后续的正常用户的连接请求将会被丢弃，从而无法连接到服务端。此为半连接攻击方式。")]),e._v(" "),_("p",[e._v("当然，发送请求的ip可能是不存在的，所以服务端会不停的超时重传，极其的消耗资源")]),e._v(" "),_("p",[_("font",{attrs:{size:"5"}},[_("strong",[e._v("半连接队列")])])],1),e._v(" "),_("p",[e._v("当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。(全连接队列：连接完全建立之后，连接放到全连接队列中，等待应用来取)")]),e._v(" "),_("p",[e._v("如何解决？")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("扩大半连接队列的大小（一种思路，但不可取）")])]),e._v(" "),_("li",[_("p",[e._v("减少 SYN + ACK 重试次数，避免大量的超时重发")])]),e._v(" "),_("li",[_("p",[e._v("利用 SYN Cookie技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie 合法之后才分配连接资源。")])]),e._v(" "),_("li",[_("p",[e._v("syn cache：系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。")])])]),e._v(" "),_("p",[_("font",{attrs:{size:"5"}},[_("strong",[e._v("全连接攻击")])])],1),e._v(" "),_("p",[e._v("全连接攻击是通过消费服务端进程数和连接数，只连接而不进行发送数据的一种攻击方式。当客户端连接到服务端，仅仅只是连接，此时服务端会为每一个连接创建一个进程来处理客户端发送的数据。但是客户端只是连接而不发送数据，此时服务端会一直阻塞在recv或者read的状态，如此一来，多个连接，服务端的每个连接都是出于阻塞状态从而导致服务端的崩溃。")]),e._v(" "),_("p",[e._v("如何来解决全连接攻击？")]),e._v(" "),_("p",[e._v("可以通过不为全连接分配进程处理的方式来防范全连接攻击，具体的情况是当收到数据之后，在为其分配一个处理线程。具体的处理方式在accept返回之前是不分配处理线程的。直到接收相关的数据之后才为之提供一个处理过程。例如在apache服务中，是通过预创建一定量的子进程作为处理连接继承。所有的自己进程都继承父进程的sockfd，每当有一个连接过来时，只有当accept返回是，才会为该链接分配一个进程来处理连接请求。负责，子进程一直处于等待状态。如果出现值是连接存在，而始终不放数据，该链接的状态是SYN_RECV，在协议栈中，提供一个保活期给该链接，如果超过保活期还没有数据到来，服务端协议栈将会断开该链接。如果没有该保活期，虽然避免了ESTABLESHED状态的数量，但是SYN_RECV的数据量的增长仍旧是不可估算的，所以需要利用保活期来监控该链接是需要清除断开。")]),e._v(" "),_("p",[e._v("参考："),_("a",{attrs:{href:"https://blog.csdn.net/qq_34687559/article/details/114582990",target:"_blank",rel:"noopener noreferrer"}},[e._v("TCP之半连接攻击 & 全连接攻击"),_("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);