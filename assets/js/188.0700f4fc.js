(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{819:function(t,s,e){"use strict";e.r(s);var v=e(15),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"数据结构持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构持久化"}},[t._v("#")]),t._v(" 数据结构持久化")]),t._v(" "),e("p",[t._v("尽管 Redis 经常会被用作内存数据库，但是，它也支持数据落盘，也就是将内存中的数据存储到硬盘中。这样，当机器断电的时候，存储在 Redis 中的数据也不会丢失。在机器重新启动之后，Redis 只需要再将存储在硬盘中的数据，重新读取到内存，就可以继续工作了。")]),t._v(" "),e("p",[t._v("刚刚我们讲到，Redis 的数据格式由“键”和“值”两部分组成。而“值”又支持很多数据类型，比如字符串、列表、字典、集合、有序集合。像字典、集合等类型，底层用到了散列表，散列表中有指针的概念，而指针指向的是内存中的存储地址。 那 Redis 是如何将这样一个跟具体内存地址有关的数据结构存储到磁盘中的呢？")]),t._v(" "),e("p",[t._v("实际上，Redis 遇到的这个问题并不特殊，很多场景中都会遇到。我们把它叫作"),e("strong",[t._v("数据结构的持久化问题")]),t._v("，或者"),e("strong",[t._v("对象的持久化问题")]),t._v("。这里的“持久化”，你可以笼统地可以理解为“存储到磁盘”。")]),t._v(" "),e("p",[t._v("如何将数据结构持久化到硬盘？我们主要有两种解决思路。")]),t._v(" "),e("p",[t._v("第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思路。")]),t._v(" "),e("p",[t._v("不过，这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时间。比如，我们现在要将散列表中的数据存储到磁盘。当我们从磁盘中，取出数据重新构建散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几 GB 的数据，那重构数据结构的耗时就不可忽视了。")]),t._v(" "),e("p",[t._v("第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。我们拿散列表这样的数据结构来举例。我们可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。")])])}),[],!1,null,null,null);s.default=_.exports}}]);