(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{862:function(t,a,_){"use strict";_.r(a);var s=_(15),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"如何解决缓存和数据库的数据不一致问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决缓存和数据库的数据不一致问题"}},[t._v("#")]),t._v(" 如何解决缓存和数据库的数据不一致问题?")]),t._v(" "),_("h1",{attrs:{id:"_1-新增数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-新增数据"}},[t._v("#")]),t._v(" 1.新增数据")]),t._v(" "),_("p",[t._v("如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作，此时，缓存中本身 就没有新增数据，而数据库中是最新值，此时，缓存和数据库的数据是一致的。")]),t._v(" "),_("h1",{attrs:{id:"_2-删改数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-删改数据"}},[t._v("#")]),t._v(" 2.删改数据")]),t._v(" "),_("p",[t._v("我们假设应用先删除缓存，再更新数据库，如果缓存删除成功，但是数据库更新失败，那么，应用再访问数据时，缓存中没有数据，就会发生缓存缺失。然后，应用再访问数据库，但是数据库中的值为旧值，应用就访问到旧值了。")]),t._v(" "),_("p",[t._v("如果我们先更新数据库，再删除缓存中的值，在删除缓存时失败了，那么，数据库中的值是新值，而缓存中的是旧值，这肯定是不一致的。这个时候，如果有其他的并发请求来访问数据，按照正常的缓存访问流程，就会先在缓存中查询，但此时，就会读到旧值了。")]),t._v(" "),_("h1",{attrs:{id:"如何解决数据不一致问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决数据不一致问题"}},[t._v("#")]),t._v(" 如何解决数据不一致问题?")]),t._v(" "),_("p",[t._v("可以采用重试机制，具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中(例如使用 Kafka 消息队列)。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消 息队列中重新读取这些值，然后再次进行删除或更新。如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。")]),t._v(" "),_("p",[t._v("刚刚说的是在更新数据库和删除缓存值的过程中，其中一个操作失败的情况，实际上，即使这两个操作第一次执行时都没有失败，当有大量并发请求时，应用还是有可能读到不一致的数据。")]),t._v(" "),_("h1",{attrs:{id:"情况一-先删除缓存-再更新数据库。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#情况一-先删除缓存-再更新数据库。"}},[t._v("#")]),t._v(" 情况一:先删除缓存，再更新数据库。")]),t._v(" "),_("p",[t._v("假设线程 A 删除缓存值后，还没有来得及更新数据库(比如说有网络延迟)，线程 B 就开 始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来 两个问题:")]),t._v(" "),_("ol",[_("li",[t._v("线程 B 读取到了旧值;")]),t._v(" "),_("li",[t._v("线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会 导致其他线程从缓存中读到旧值。")])]),t._v(" "),_("p",[t._v("等到线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，缓存 中的数据是旧值，而数据库中的是最新值，两者就不一致了。")]),t._v(" "),_("p",[t._v("这该怎么办呢?我来给你提供一种解决方案。")]),t._v(" "),_("p",[_("strong",[t._v("在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。")]),t._v(" 我们也把它叫做“延迟双删”。")]),t._v(" "),_("h1",{attrs:{id:"情况二-先更新数据库值-再删除缓存值。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#情况二-先更新数据库值-再删除缓存值。"}},[t._v("#")]),t._v(" 情况二:先更新数据库值，再删除缓存值。")]),t._v(" "),_("p",[t._v("如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了， 那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这 种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。 而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存 缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。")])])}),[],!1,null,null,null);a.default=v.exports}}]);