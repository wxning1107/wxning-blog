(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{509:function(t,a,r){t.exports=r.p+"assets/img/image-20211103181849510.1c4a4fac.png"},510:function(t,a,r){t.exports=r.p+"assets/img/image-20211103181926991.2a929e28.png"},925:function(t,a,r){"use strict";r.r(a);var s=r(15),_=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"高效的动态插入、删除、查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高效的动态插入、删除、查找"}},[t._v("#")]),t._v(" 高效的动态插入、删除、查找")]),t._v(" "),s("p",[t._v("二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？实际上，我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫作"),s("strong",[t._v("跳表")]),t._v("（Skip list）。")]),t._v(" "),s("p",[t._v("跳表是一种各方面性能都比较优秀的"),s("strong",[t._v("动态数据结构")]),t._v("，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代"),s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91",target:"_blank",rel:"noopener noreferrer"}},[t._v("红黑树"),s("OutboundLink")],1),t._v("（Red-black tree）。")]),t._v(" "),s("h1",{attrs:{id:"如何理解跳表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何理解跳表"}},[t._v("#")]),t._v(" 如何理解跳表？")]),t._v(" "),s("p",[t._v("对链表建立一级“索引”，每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作"),s("strong",[t._v("索引")]),t._v("或"),s("strong",[t._v("索引层")]),t._v("。图中的 down 表示 down 指针，指向下一级结点。")]),t._v(" "),s("p",[s("img",{attrs:{src:r(509),alt:"img"}})]),t._v(" "),s("p",[t._v("我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。")]),t._v(" "),s("p",[s("img",{attrs:{src:r(510),alt:"img"}})]),t._v(" "),s("p",[s("strong",[t._v("这种链表加多级索引的结构，就是跳表")]),t._v("。")]),t._v(" "),s("h1",{attrs:{id:"用跳表查询到底有多快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用跳表查询到底有多快"}},[t._v("#")]),t._v(" 用跳表查询到底有多快？")]),t._v(" "),s("p",[t._v("在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找。")]),t._v(" "),s("h1",{attrs:{id:"跳表是不是很浪费内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跳表是不是很浪费内存"}},[t._v("#")]),t._v(" 跳表是不是很浪费内存？")]),t._v(" "),s("p",[t._v("比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。跳表的空间复杂度是 O(n)。")]),t._v(" "),s("h1",{attrs:{id:"高效的动态插入和删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高效的动态插入和删除"}},[t._v("#")]),t._v(" 高效的动态插入和删除")]),t._v(" "),s("p",[t._v("跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。")]),t._v(" "),s("p",[t._v("我们知道，在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。")]),t._v(" "),s("p",[t._v("对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。")]),t._v(" "),s("p",[t._v("在删除时如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。")])])}),[],!1,null,null,null);a.default=_.exports}}]);