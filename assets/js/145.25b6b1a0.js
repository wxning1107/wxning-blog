(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{664:function(l,t,v){l.exports=v.p+"assets/img/image-20211126104017905.07988d77.png"},936:function(l,t,v){"use strict";v.r(t);var e=v(15),a=Object(e.a)({},(function(){var l=this,t=l.$createElement,e=l._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[e("h1",{attrs:{id:"缓存淘汰策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存淘汰策略"}},[l._v("#")]),l._v(" 缓存淘汰策略")]),l._v(" "),e("p",[e("img",{attrs:{src:v(664),alt:"img"}})]),l._v(" "),e("p",[l._v("默认情况下，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据，也就是设定的 noeviction 策略。一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。")]),l._v(" "),e("p",[l._v("我们再分析下 volatile-random、volatile-ttl、volatile-lru 和 volatile-lfu 这四种淘汰策略。它们筛选的候选数据范围，被限制在已经设置了过期时间的键值对上。")]),l._v(" "),e("ul",[e("li",[l._v("volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。")]),l._v(" "),e("li",[l._v("volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。")]),l._v(" "),e("li",[l._v("volatile-lru 会使用 LRU 算法筛选设置了过期时间的键值对。")]),l._v(" "),e("li",[l._v("volatile-lfu 会使用 LFU 算法选择设置了过期时间的键值对。")])]),l._v(" "),e("p",[l._v("allkeys-lru、allkeys-random、allkeys-lfu 这三种淘汰策略的备选淘汰数据范围，就扩大到了所有键值对，无论这些键值对是否设置了过期时间。它们筛选数据进行淘汰的规则是：")]),l._v(" "),e("ul",[e("li",[l._v("allkeys-random 策略，从所有键值对中随机选择并删除数据；")]),l._v(" "),e("li",[l._v("allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选。")]),l._v(" "),e("li",[l._v("allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选。")])]),l._v(" "),e("h1",{attrs:{id:"对-lru-算法优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对-lru-算法优化"}},[l._v("#")]),l._v(" 对 LRU 算法优化")]),l._v(" "),e("p",[l._v("LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。")]),l._v(" "),e("p",[l._v("所以，在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。")]),l._v(" "),e("p",[l._v("当需要再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。这儿的挑选标准是：能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值。当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了 maxmemorysamples，Redis 就把候选数据集中 lru 字段值最小的数据淘汰出去。")]),l._v(" "),e("p",[l._v("这样一来，Redis 缓存不用为所有的数据维护一个大链表，也不用在每次数据访问时都移动链表项，提升了缓存的性能。")]),l._v(" "),e("h1",{attrs:{id:"缓存策略选择"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存策略选择"}},[l._v("#")]),l._v(" 缓存策略选择")]),l._v(" "),e("p",[l._v("优先使用 allkeys-lru 策略。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。")]),l._v(" "),e("p",[l._v("如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选")]),l._v(" "),e("h1",{attrs:{id:"缓存污染问题-lfu-策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存污染问题-lfu-策略"}},[l._v("#")]),l._v(" 缓存污染问题---LFU 策略")]),l._v(" "),e("p",[l._v("什么是缓存污染呢？在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。这种情况，就是缓存污染。")]),l._v(" "),e("p",[l._v("volatile-random 和 allkeys-random 这两种策略都是采用随机挑选数据的方式，来筛选即将被淘汰的数据。既然是随机挑选，那么 Redis 就不会根据数据的访问情况来筛选数据。如果被淘汰的数据\n又被访问了，就会发生缓存缺失。在避免缓存污染这个问题上的效果非常有限。")]),l._v(" "),e("p",[l._v("volatile-ttl 针对的是设置了过期时间的数据，把这些数据中剩余存活时间最短的筛选出来并淘汰掉。虽然 volatile-ttl 策略不再是随机选择淘汰数据了，但是剩余存活时间并不能直接反映数据再次访问的情况。所以，按照 volatile-ttl 策略淘汰数据，和按随机方式淘汰数据类似，也可能出现数据被淘汰后，被再次访问导致的缓存缺失问题。")]),l._v(" "),e("p",[l._v("所以 volatile-random、allkeys-random、volatile-ttl 这三种策略并不能应对缓存污染问题。")]),l._v(" "),e("p",[l._v("而 LRU 策略因为只看数据的访问时间，所以可以一定程度上避免缓存污染，但是使用 LRU 策略在处理扫描式单次查询操作时，无法解决缓存污染。所谓的扫描式单次查询操作，就是指应用对大量的数据进行一次全体读取，每个数据都会被读取，而且只会被读取一次。此时，因为这些被查询的数据刚刚被访问过，所以 lru 字段值都很大。")]),l._v(" "),e("p",[l._v("为了应对这类缓存污染问题，Redis 从 4.0 版本开始增加了 LFU 淘汰策略。")]),l._v(" "),e("p",[l._v("LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。")]),l._v(" "),e("p",[l._v("和那些被频繁访问的数据相比，扫描式单次查询的数据因为不会被再次访问，所以它们的访问次数不会再增加。因此，LFU 策略会优先把这些访问次数低的数据淘汰出缓存。这样一来，LFU 策略就可以避免这些数据对缓存造成污染了。")]),l._v(" "),e("p",[e("strong",[l._v("LFU 策略具体又是如何实现的呢？")])]),l._v(" "),e("ul",[e("li",[l._v("为了避免操作链表的开销，Redis 在实现 LRU 策略时使用了两个近似方法：Redis 是用 RedisObject 结构来保存数据的，RedisObject 结构中设置了一个 lru 字段，用来记录数据的访问时间戳；")]),l._v(" "),e("li",[l._v("Redis 并没有为所有的数据维护一个全局的链表，而是通过随机采样方式，选取一定数量（例如 10 个）的数据放入候选集合，后续在候选集合中根据 lru 字段值的大小进行筛选。")])]),l._v(" "),e("p",[l._v("在此基础上，Redis 在实现 LFU 策略的时候，只是把原来 24bit 大小的 lru 字段，又进一步拆分成了两部分。")]),l._v(" "),e("ul",[e("li",[l._v("ldt 值：lru 字段的前 16bit，表示数据的访问时间戳；")]),l._v(" "),e("li",[l._v("counter 值：lru 字段的后 8bit，表示数据的访问次数。")])]),l._v(" "),e("p",[l._v("总结一下：当 LFU 策略筛选数据时，Redis 会在候选集合中，根据数据 lru 字段的后 8bit 选择访问次数最少的数据进行淘汰。当访问次数相同时，再根据 lru 字段的前 16bit 值大小，选择访问时间最久远的数据进行淘汰。")]),l._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[l._v("注意")]),l._v(" "),e("p",[l._v("为了避免 counter 值溢出，在实现 LFU 策略时，Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，而是采用了一个更优化的计数规则。")]),l._v(" "),e("p",[l._v("简单来说，LFU 策略实现的计数规则是：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。")])])])}),[],!1,null,null,null);t.default=a.exports}}]);