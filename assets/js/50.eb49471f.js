(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{427:function(t,s,n){t.exports=n.p+"assets/img/image-20211103132126314.7e0741bf.png"},553:function(t,s,n){"use strict";n.r(s);var e=n(15),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"快排和归并区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快排和归并区别"}},[t._v("#")]),t._v(" 快排和归并区别")]),t._v(" "),e("p",[t._v("快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？")]),t._v(" "),e("p",[e("img",{attrs:{src:n(427),alt:"img"}})]),t._v(" "),e("p",[t._v("可以发现，归并排序的处理过程是"),e("strong",[t._v("由下到上")]),t._v("的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是"),e("strong",[t._v("由上到下")]),t._v("的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。")])])}),[],!1,null,null,null);s.default=r.exports}}]);