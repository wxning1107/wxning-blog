(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{413:function(a,t,r){a.exports=r.p+"assets/media/Map长啥样儿？.1f51e6e6.mp4"},414:function(a,t,r){a.exports=r.p+"assets/img/image-20220301162005445.d14a39e3.png"},936:function(a,t,r){"use strict";r.r(t);var e=r(15),p=Object(e.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"map相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map相关"}},[a._v("#")]),a._v(" map相关")]),a._v(" "),e("video",{attrs:{id:"video",width:"1000px",height:"600px",controls:"controls"}},[e("source",{attrs:{id:"mp4",src:r(413),type:"video/mp4"}})]),a._v(" "),e("h1",{attrs:{id:"_1-map-锁和sync-map怎么选择"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-map-锁和sync-map怎么选择"}},[a._v("#")]),a._v(" 1."),e("strong",[a._v("map+锁和sync.Map怎么选择？")])]),a._v(" "),e("p",[a._v("sync.Map的性能高体现在读操作远多于写操作的时候。 极端情况下，只有读操作时，是普通map的性能的44.3倍。")]),a._v(" "),e("p",[a._v("反过来，如果是全写，没有读，那么sync.Map还不如加普通map+mutex锁呢。只有普通map性能的一半。")]),a._v(" "),e("p",[a._v("建议使用sync.Map时一定要考虑读定比例。当写操作只占总操作的<=1/10的时候，使用sync.Map性能会明显高很多。")]),a._v(" "),e("h1",{attrs:{id:"_2-sync-map底层原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-sync-map底层原理"}},[a._v("#")]),a._v(" 2."),e("strong",[a._v("sync.Map底层原理：")])]),a._v(" "),e("p",[a._v("参考："),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/344834329",target:"_blank",rel:"noopener noreferrer"}},[a._v("知乎专栏文章"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("code",[a._v("sync.map")]),a._v(" 适用于读多写少的场景。对于写多的场景，会导致 read map 缓存失效，需要加锁，导致冲突变多；而且由于未命中 read map 次数过多，导致 dirty map 提升为 read map，这是一个 O(N) 的操作，会进一步降低性能。")]),a._v(" "),e("p",[a._v("参考："),e("a",{attrs:{href:"https://blog.csdn.net/u011957758/article/details/96633984",target:"_blank",rel:"noopener noreferrer"}},[a._v("csdn文章"),e("OutboundLink")],1)]),a._v(" "),e("p",[a._v("sync.Map的原理很简单，使用了空间换时间策略，通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。")]),a._v(" "),e("p",[a._v("通过引入两个map将读写分离到不同的map，其中read map提供并发读和已存元素原子写，而dirty map则负责读写。")]),a._v(" "),e("p",[a._v("这样read map就可以在不加锁的情况下进行并发读取,当read map中没有读取到值时,再加锁进行后续读取,并累加未命中数。")]),a._v(" "),e("p",[a._v("当未命中数大于等于dirty map长度,将dirty map上升为read map。")]),a._v(" "),e("p",[a._v("从结构体的定义可以发现，虽然引入了两个map，但是底层数据存储的是指针，指向的是同一份值。")]),a._v(" "),e("h1",{attrs:{id:"_3-map底层实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-map底层实现"}},[a._v("#")]),a._v(" 3."),e("strong",[a._v("map底层实现？")])]),a._v(" "),e("p",[a._v("参考："),e("a",{attrs:{href:"https://www.bilibili.com/video/BV1Sp4y1U7dJ?from=search&seid=17900809635826536017&spm_id_from=333.337.0.0",target:"_blank",rel:"noopener noreferrer"}},[a._v("B站视频"),e("OutboundLink")],1)]),a._v(" "),e("p",[a._v("参考："),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/66676224",target:"_blank",rel:"noopener noreferrer"}},[a._v("知乎文章"),e("OutboundLink")],1)]),a._v(" "),e("p",[a._v("map扩容机制(来源于上面B站视频)：")]),a._v(" "),e("p",[e("img",{attrs:{src:r(414),alt:"img"}})]),a._v(" "),e("p",[a._v("负载因子超过6.5触发"),e("strong",[a._v("翻倍扩容")])]),a._v(" "),e("p",[a._v("负载因子未超标，但是使用的溢出桶较多触发"),e("strong",[a._v("等量扩容")]),a._v("，具体是：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("常规桶数小于2^15，溢出桶数目超过常规桶")])]),a._v(" "),e("li",[e("p",[a._v("常规桶数大于2^15，溢出桶数目大于2^25")])])]),a._v(" "),e("p",[a._v("等量扩容就是创建和旧桶数量一样多的新桶，然后把键值对迁移至新桶中，那等量扩容有什么用呢？")]),a._v(" "),e("p",[a._v("其实这个规则是桶的负载因子没有超过上限值，但是使用了较多溢出桶，这种情况对应着很多键值对被删除的情况。这样迁移到新桶后能够使得键值对排列更加紧凑，并且减少溢出桶的使用。")])])}),[],!1,null,null,null);t.default=p.exports}}]);