(window.webpackJsonp=window.webpackJsonp||[]).push([[352],{1340:function(s,a,t){"use strict";t.r(a);var n=t(15),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"redis如何应对并发访问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis如何应对并发访问"}},[s._v("#")]),s._v(" Redis如何应对并发访问?")]),s._v(" "),t("p",[s._v("为了保证并发访问的正确性，Redis 提供了两种方法，分别是加锁和原子操作。")]),s._v(" "),t("h1",{attrs:{id:"原子操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原子操作"}},[s._v("#")]),s._v(" 原子操作")]),s._v(" "),t("p",[s._v("假设客户端要对商品库存执行扣减 1 的操作，伪代码如下所示:")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" GET"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" current--\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" SET"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("id, current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("客户端首先会根据商品 id，从 Redis 中读取商品当前的库存值 current，然后，客户端对库存值减 1，再把库存值写回 Redis。")]),s._v(" "),t("p",[s._v("临界区代码中的客户端读取数据、更新数据、再写回数据涉及了三个操作，而这三个操作在执行时并不具有互斥性，多个客户端基于相同的初始值进行修改，而不是基于前一个客户端修改后的值再修改就会产生并发问题。")]),s._v(" "),t("p",[s._v("Redis 的原子操作采用了两种方法:")]),s._v(" "),t("p",[s._v("1.把多个操作在 Redis 中实现成一个操作，也就是单命令操作;")]),s._v(" "),t("p",[s._v("2.把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。")]),s._v(" "),t("p",[s._v("Redis 提供了 INCR/DECR 命令，把这三个操作转变为一个原子操作了。 INCR/DECR 命令可以对数据进行增值 / 减值操作，而且它们本身就是单个命令操作， Redis 在执行它们时，本身就具有互斥性。")]),s._v(" "),t("p",[s._v("比如说，在刚才的库存扣减例子中，客户端可以使用下面的代码，直接完成对商品 id 的库 存值减 1 操作。即使有多个客户端执行下面的代码，也不用担心出现库存值扣减错误的问题。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("DECR "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("id")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[s._v("但是，如果我们要执行的操作不是简单地增减数据，而是有更加复杂的判断逻辑或者是其他操作，那么，Redis 的单命令操作已经无法保证多个操作的互斥执行了。所以，这个时候我们需要使用第二个方法，也就是 Lua 脚本。")]),s._v(" "),t("p",[s._v("Redis 会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而 保证了 Lua 脚本中操作的原子性。")]),s._v(" "),t("p",[s._v("我再给你举个例子，当一个业务应用的访问用户增加时，我们有时需要限制某个客户端在一定时间范围内的访问次数，比如爆款商品的购买限流、社交网络中的每分钟点赞次数限制等。")]),s._v(" "),t("p",[s._v("那该怎么限制呢?我们可以把客户端 IP 作为 key，把客户端的访问次数作为 value，保存 到 Redis 中。客户端每访问一次后，我们就用 INCR 增加访问次数。")]),s._v(" "),t("p",[s._v("不过，在这种场景下，客户端限流其实同时包含了对访问次数和时间范围的限制，例如每 分钟的访问次数不能超过 20。所以，我们可以在客户端第一次访问时，给对应键值对设置 过期时间，例如设置为 60s 后过期。同时，在客户端每次访问时，我们读取客户端当前的 访问次数，如果次数超过阈值，就报错，限制客户端再次访问。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("//获取ip对应的访问次数\ncurrent "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" GET"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ip"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" \n//如果超过访问次数超过20次，则报错\nIF current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!=")]),s._v(" NULL AND current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("20")]),s._v(" THEN\n    ERROR "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"exceed 20 accesses per second"')]),s._v("\nELSE\n    //如果访问次数不足20次，增加一次访问计数\n    value "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" INCR"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ip"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" //如果是第一次访问，将键值对的过期时间设置为60s后 \n    IF value "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" THEN\n        EXPIRE"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ip,60"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    END\n    //执行其他操作\n    DO THINGS \nEND\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br")])]),t("p",[s._v("我们已经使用了 INCR 来原子性地增加计数。但是，客户端限流的逻辑不只有计数，还包括访问次数判断和过期时间设置。对于这些操作，我们同样需要保证它们的原子性。所以，这个例子中的操作无法用 Redis 单个命令来实现，此时，我们就可以使用 Lua 脚本 来保证并发控制。我们可以把访问次数加 1、判断访问次数是否为 1，以及设置过期时间这 三个操作写入一个 Lua 脚本，如下所示:")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("local")]),s._v(" current\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" redis.call"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"incr"')]),s._v(",KEYS"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" tonumber"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("then")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v("     redis.call"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"expire"')]),s._v(",KEYS"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(",60"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" end\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("假设我们编写的脚本名称为 lua.script，我们接着就可以使用 Redis 客户端，带上 eval 选 项，来执行该脚本。脚本所需的参数将通过以下命令中的 keys 和 args 进行传递。")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("redis-cli --eval lua.script keys , args\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])])])}),[],!1,null,null,null);a.default=e.exports}}]);