(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{1152:function(t,s,e){"use strict";e.r(s);var a=e(15),i=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"霍夫曼编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#霍夫曼编码"}},[t._v("#")]),t._v(" 霍夫曼编码")]),t._v(" "),a("p",[t._v("我们讲下霍夫曼编码，看看"),a("strong",[t._v("它是如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的")]),t._v("。")]),t._v(" "),a("p",[t._v("假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？")]),t._v(" "),a("p",[t._v("假设我们通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("a(000)、b(001)、c(010)、d(011)、e(100)、f(101)\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("霍夫曼编码就要登场了。霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。")]),t._v(" "),a("p",[t._v("霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。")]),t._v(" "),a("p",[t._v("对于等长的编码来说，我们解压缩起来很简单。比如刚才那个例子中，我们用 3 个 bit 表示一个字符。在解压缩的时候，我们每次从文本中读取 3 位二进制码，然后翻译成对应的字符。但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(641),alt:"img"}})]),t._v(" "),a("p",[t._v("假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(642),alt:"img"}})]),t._v(" "),a("p",[t._v("尽管霍夫曼编码的思想并不难理解，但是如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？这里的处理稍微有些技巧。")]),t._v(" "),a("p",[t._v("我们把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(643),alt:"img"}})]),t._v(" "),a("p",[t._v("现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(644),alt:"img"}})])])}),[],!1,null,null,null);s.default=i.exports},641:function(t,s,e){t.exports=e.p+"assets/img/image-20211105110940294.4ddee959.png"},642:function(t,s,e){t.exports=e.p+"assets/img/image-20211105111054409.8098c77c.png"},643:function(t,s,e){t.exports=e.p+"assets/img/image-20211105111129433.2782b23c.png"},644:function(t,s,e){t.exports=e.p+"assets/img/image-20211105111146971.20433198.png"}}]);