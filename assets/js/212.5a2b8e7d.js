(window.webpackJsonp=window.webpackJsonp||[]).push([[212],{873:function(n,e,a){"use strict";a.r(e);var _=a(15),v=Object(_.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"channel相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#channel相关"}},[n._v("#")]),n._v(" channel相关")]),n._v(" "),a("h1",{attrs:{id:"_1-channel实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-channel实现原理"}},[n._v("#")]),n._v(" 1.channel实现原理")]),n._v(" "),a("p",[n._v("channel底层是一个Hchan结构体，他有几个重要的部分：一个核心部分是channel数据的环形队列，包括队列的大小，容量，当前使用量。还有一部分是两个链表，一个是记录读通道而阻塞的goroutine，一个是写通道阻塞的goroutine，就是说如果一个goroutine阻塞于channel了，那么它就被挂在recvq或sendq中")]),n._v(" "),a("p",[n._v("等待队列：")]),n._v(" "),a("p",[n._v("从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。 向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。")]),n._v(" "),a("p",[n._v("被阻塞的goroutine将会挂在channel的等待队列中：")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；")])]),n._v(" "),a("li",[a("p",[n._v("因写阻塞的goroutine会被从channel读数据的goroutine唤醒；")])])]),n._v(" "),a("p",[n._v("创建channel：")]),n._v(" "),a("p",[n._v("创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定。")]),n._v(" "),a("p",[n._v("向channel写数据：")]),n._v(" "),a("p",[n._v("1.如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；")]),n._v(" "),a("p",[n._v("2.如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；")]),n._v(" "),a("p",[n._v("3.如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；")]),n._v(" "),a("p",[n._v("从channel读数据：")]),n._v(" "),a("p",[n._v("从一个channel读数据简单过程如下：")]),n._v(" "),a("p",[n._v("1.如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；")]),n._v(" "),a("p",[n._v("2.如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；")]),n._v(" "),a("p",[n._v("3.如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；")]),n._v(" "),a("p",[n._v("4.将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；")]),n._v(" "),a("p",[n._v("关闭channel：")]),n._v(" "),a("p",[n._v("关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。")]),n._v(" "),a("p",[n._v("除此之外，panic出现的常见场景还有：")]),n._v(" "),a("p",[n._v("1.关闭值为nil的channel")]),n._v(" "),a("p",[n._v("2.关闭已经被关闭的channel")]),n._v(" "),a("p",[n._v("3.向已经关闭的channel写数据")]),n._v(" "),a("h1",{attrs:{id:"_2-如何判断channel已经被关闭"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何判断channel已经被关闭"}},[n._v("#")]),n._v(" 2.如何判断channel已经被关闭？")]),n._v(" "),a("p",[n._v("参考："),a("a",{attrs:{href:"https://www.zhihu.com/question/450188866",target:"_blank",rel:"noopener noreferrer"}},[n._v("知乎文章"),a("OutboundLink")],1)]),n._v(" "),a("h1",{attrs:{id:"_3-channel使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-channel使用场景"}},[n._v("#")]),n._v(" 3.channel使用场景？")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("停止信号")])]),n._v(" "),a("li",[a("p",[n._v("任务定时")])]),n._v(" "),a("li",[a("p",[n._v("解藕生产方和消费方")])]),n._v(" "),a("li",[a("p",[n._v("控制并发数")])])]),n._v(" "),a("p",[n._v("主要不应该是goroutine之间的通信嘛？？？")]),n._v(" "),a("p",[n._v("参考："),a("a",{attrs:{href:"https://qcrao91.gitbook.io/go/channel/channel-you-na-xie-ying-yong",target:"_blank",rel:"noopener noreferrer"}},[n._v("qcrao91博客"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=v.exports}}]);