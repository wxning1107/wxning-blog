(window.webpackJsonp=window.webpackJsonp||[]).push([[450],{1553:function(n,s,t){"use strict";t.r(s);var _=t(15),e=Object(_.a)({},(function(){var n=this,s=n.$createElement,t=n._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"什么是-syn-flood-如何防止这类攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-syn-flood-如何防止这类攻击"}},[n._v("#")]),n._v(" 什么是 SYN flood，如何防止这类攻击？")]),n._v(" "),t("p",[n._v("最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。")]),n._v(" "),t("p",[n._v("如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被响应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。")]),n._v(" "),t("p",[n._v("常见的防攻击方法有：")]),n._v(" "),t("p",[t("font",{attrs:{size:"5"}},[t("strong",[n._v("无效连接的监视释放")])])],1),n._v(" "),t("p",[n._v("监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。")]),n._v(" "),t("p",[t("font",{attrs:{size:"5"}},[t("strong",[n._v("延缓TCB分配方法")])])],1),n._v(" "),t("p",[n._v("消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。")]),n._v(" "),t("p",[t("font",{attrs:{size:"5"}},[t("strong",[n._v("Syn Cache技术")])])],1),n._v(" "),t("p",[n._v("系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。")]),n._v(" "),t("p",[t("font",{attrs:{size:"5"}},[t("strong",[n._v("Syn Cookie技术")])])],1),n._v(" "),t("p",[n._v("Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。")]),n._v(" "),t("p",[t("font",{attrs:{size:"5"}},[t("strong",[n._v("使用SYN Proxy防火墙")])])],1),n._v(" "),t("p",[n._v("一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c', 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。")]),n._v(" "),t("hr"),n._v(" "),t("p",[n._v("什么是TCP半连接队列和全连接队列？")]),n._v(" "),t("p",[n._v("在TCP进行三次握手时，Liunx会为其维护两个队列：")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("半连接队列，也叫syn队列")])]),n._v(" "),t("li",[t("p",[n._v("全连接队列，也叫accept队列")])])]),n._v(" "),t("p",[n._v("在客户端发起第一次连接时，服务端会将其加入到syn队列中，并且响应客户端syn+ack报文，等到客户端发送ack应答报文时，服务端将该连接从半连接队列中取出，并新建一个新的连接，加入到accept队列当中。等待进程调用accept请求时，将该连接取出来。")]),n._v(" "),t("p",[n._v("不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。")]),n._v(" "),t("p",[n._v("我们只需要一直对服务端发送syn包，但是不回ack回应包，这样就会使得服务端有大量请求处于syn_recv状态，这就是所谓的syn洪泛，syn攻击，DDos攻击。")]),n._v(" "),t("p",[t("font",{attrs:{size:"5"}},[t("strong",[n._v("如何抵御syn攻击")])])],1),n._v(" "),t("ul",[t("li",[t("p",[n._v("增大半连接队列")]),n._v(" "),t("p",[n._v("不能只增大tcp_max_syn_backlog,还需要一同增大somaconn和backlog，也就是增大全连接队列")])]),n._v(" "),t("li",[t("p",[n._v("开启tcp_syncookies功能")]),n._v(" "),t("p",[n._v("开启tcp_syncookies就可以在不使用syn半连接队列的情况下建立连接，syncookies在接收到客户端的syn报文时，计算出一个值，放到syn+ack报文中发出。当客户端返回ack报文时，取出该值验证，成功则建立连接")])]),n._v(" "),t("li",[t("p",[n._v("减少ack+syn报文的重传次数")]),n._v(" "),t("p",[n._v("因为我们在收到syn攻击时，服务端会重传syn+ack报文到最大次数，才会断开连接。针对syn攻击的场景，我们可以减少ack+syn报文的重传次数，使处于syn_recv状态的它们更快断开连接，修改重传次数:/proc/sys/net/ipv4/tcp_synack_retries")])])]),n._v(" "),t("p",[t("font",{attrs:{size:"5"}},[t("strong",[n._v("全连接队列溢出")])])],1),n._v(" "),t("p",[n._v("当服务端的全连接队列过小时，容易发生全连接队列溢出。发生全连接队列溢出，后续的请求就会别丢弃。Linux有个参数可以指定TCP全连接队列满了，会使用什么策略来回应客户端。丢弃连接只是liunx的默认行为，我们还可以向客户端发送RST报文终止连接，告诉客户端连接失败。（通常情况下丢弃更好，可以提高效率）")]),n._v(" "),t("p",[n._v("当全连接队列溢出后，我们需要增大全连接队列的长度，以提高请求容量。")]),n._v(" "),t("p",[n._v("参考："),t("a",{attrs:{href:"https://blog.csdn.net/small_engineer/article/details/124190620",target:"_blank",rel:"noopener noreferrer"}},[n._v("TCP半连接队列和全连接队列"),t("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);