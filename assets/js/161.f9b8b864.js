(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{673:function(s,t,a){s.exports=a.p+"assets/img/image-20211128121225640.637d5214.png"},998:function(s,t,a){"use strict";a.r(t);var v=a(15),_=Object(v.a)({},(function(){var s=this,t=s.$createElement,v=s._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h1",{attrs:{id:"全局锁和表锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全局锁和表锁"}},[s._v("#")]),s._v(" 全局锁和表锁")]),s._v(" "),v("h1",{attrs:{id:"全局锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[s._v("#")]),s._v(" 全局锁")]),s._v(" "),v("p",[s._v("顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。")]),s._v(" "),v("p",[s._v("全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。")]),s._v(" "),v("h1",{attrs:{id:"表级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[s._v("#")]),s._v(" 表级锁")]),s._v(" "),v("p",[s._v("MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。")]),s._v(" "),v("p",[s._v("表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。")]),s._v(" "),v("p",[v("strong",[s._v("另一类表级的锁是 MDL（metadata lock)")]),s._v("。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。")]),s._v(" "),v("p",[s._v("因此，在 MySQL 5.5 版本中引入了 MDL，"),v("strong",[s._v("当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。")])]),s._v(" "),v("ul",[v("li",[v("p",[s._v("读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。")])]),s._v(" "),v("li",[v("p",[s._v("读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。")])])]),s._v(" "),v("h1",{attrs:{id:"给表加字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#给表加字段"}},[s._v("#")]),s._v(" 给表加字段")]),s._v(" "),v("p",[s._v("虽然 MDL 锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。")]),s._v(" "),v("p",[s._v("你肯定知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表 t 是一个小表。")]),s._v(" "),v("p",[v("img",{attrs:{src:a(673),alt:"img"}})]),s._v(" "),v("p",[s._v("我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。")]),s._v(" "),v("p",[s._v("之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。")]),s._v(" "),v("p",[s._v("如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。")]),s._v(" "),v("p",[s._v("如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。")]),s._v(" "),v("p",[s._v("你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。")]),s._v(" "),v("p",[s._v("基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？")]),s._v(" "),v("p",[s._v("首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。")]),s._v(" "),v("p",[s._v("但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？")]),s._v(" "),v("p",[s._v("这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。")])])}),[],!1,null,null,null);t.default=_.exports}}]);