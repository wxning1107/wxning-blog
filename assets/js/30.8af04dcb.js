(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{401:function(a,s,t){a.exports=t.p+"assets/img/image-20211102212658325.faca46f5.png"},402:function(a,s,t){a.exports=t.p+"assets/img/image-20211102212904996.13ab076d.png"},403:function(a,s,t){a.exports=t.p+"assets/img/image-20211102213023713.6b8df22e.png"},750:function(a,s,t){"use strict";t.r(s);var n=t(15),r=Object(n.a)({},(function(){var a=this,s=a.$createElement,n=a._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[a._v("#")]),a._v(" 数组")]),a._v(" "),n("p",[n("strong",[a._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。")])]),a._v(" "),n("h2",{attrs:{id:"随机访问"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#随机访问"}},[a._v("#")]),a._v(" 随机访问")]),a._v(" "),n("p",[a._v("我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10] 来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。")]),a._v(" "),n("p",[n("img",{attrs:{src:t(401),alt:"img"}})]),a._v(" "),n("p",[a._v("我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：")]),a._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[a._v("a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("_address "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" base_address "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" i "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" data_type_size\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("p",[a._v("其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。")]),a._v(" "),n("h2",{attrs:{id:"低效的插入和删除"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#低效的插入和删除"}},[a._v("#")]),a._v(" 低效的插入和删除")]),a._v(" "),n("p",[a._v("假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。")]),a._v(" "),n("p",[a._v("如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。")]),a._v(" "),n("p",[n("img",{attrs:{src:t(402),alt:"img"}})]),a._v(" "),n("p",[a._v("利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。"),n("strong",[a._v("这个处理思想在快排中也会用到。")])]),a._v(" "),n("p",[a._v("我们再来看"),n("strong",[a._v("删除操作")]),a._v("。")]),a._v(" "),n("p",[a._v("跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。")]),a._v(" "),n("p",[a._v("实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？")]),a._v(" "),n("p",[a._v("我们继续来看例子。数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。")]),a._v(" "),n("p",[n("img",{attrs:{src:t(403),alt:"img"}})]),a._v(" "),n("p",[a._v("为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。")]),a._v(" "),n("p",[a._v("如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，"),n("strong",[a._v("很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的")]),a._v("。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。")]),a._v(" "),n("h2",{attrs:{id:"警惕数组的访问越界问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#警惕数组的访问越界问题"}},[a._v("#")]),a._v(" 警惕数组的访问越界问题")]),a._v(" "),n("p",[a._v("首先，我请你来分析一下这段 C 语言代码的运行结果：")]),a._v(" "),n("div",{staticClass:"language-c line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" argc"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" argv"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<=")]),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        arr"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[a._v('"hello world\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br")])]),n("p",[a._v("你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？")]),a._v(" "),n("p",[a._v("因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 a[3] 访问越界。")]),a._v(" "),n("p",[a._v("我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。")]),a._v(" "),n("h2",{attrs:{id:"为什么数组要从-0-开始编号-而不是从-1-开始呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么数组要从-0-开始编号-而不是从-1-开始呢"}},[a._v("#")]),a._v(" 为什么数组要从 0 开始编号，而不是从 1 开始呢？")]),a._v(" "),n("p",[a._v("从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：")]),a._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[a._v("a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("k"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("_address "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" base_address "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" k "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" type_size\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("p",[a._v("但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：")]),a._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[a._v("a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("k"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("_address "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" base_address "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("k"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("type_size\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br")])]),n("p",[a._v("对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。")]),a._v(" "),n("p",[a._v("另外，最主要的原因可能是历史原因：")]),a._v(" "),n("p",[a._v("C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。")])])}),[],!1,null,null,null);s.default=r.exports}}]);