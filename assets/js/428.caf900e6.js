(window.webpackJsonp=window.webpackJsonp||[]).push([[428],{1429:function(t,v,_){"use strict";_.r(v);var s=_(15),p=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"简述自旋锁与互斥锁的使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简述自旋锁与互斥锁的使用场景"}},[t._v("#")]),t._v(" 简述自旋锁与互斥锁的使用场景")]),t._v(" "),_("p",[t._v("我们知道可以通过锁来保护临界区的互斥性，如果尝试获得锁失败了，第一种策略是屡败屡战不断重复尝试，直到成功获得锁或者时间片耗完，这被称为自旋锁。")]),t._v(" "),_("p",[t._v("第二种策略是乖乖让出cpu，听从操作系统的安排进入等待队列，我们称之为调度器对象，通俗理解就是操作系统提供的线程间同步原语，一般以一组系统调用的形式存在，比如linux的futex等。基于这些同步原语，可以实现锁以及更复杂的同步工具，这些调度器对象与自旋锁的不同之处主要在于等待队列，这些同步原语是由内核提供的，直接与系统的调度器交互，能够挂起和唤醒线程，这一点是自旋锁做不到的，但也正由于其在内核中实现，所以应用程序需要以系统调用的方式来使用它，这就造成来一定开销，而且获取锁失败时还会发生线程切换，使得开销进一步增大。所以说，调度器对象和自旋锁各有各的应用场景。")]),t._v(" "),_("p",[t._v("如果是多核环境，且持有锁的时间占比较小的情况，往往在几次自旋之后就能获得锁，这比发生一次线程切换的代价小得多。")]),t._v(" "),_("p",[t._v("然而若是单核环境，或者持有锁的时间占比较大的情况，一味自旋空耗cpu反而得不偿失。")]),t._v(" "),_("p",[t._v("而实际的业务逻辑中，持有锁的时间往往不是很确定，如果加锁时先经过自旋锁，但是限制最大自旋次数，若在有限次数内不能加锁成功，再通过调度器对象将当前线程挂起，这样就结合了二者的优点，也是如今主流的锁实现思路。")]),t._v(" "),_("p",[_("font",{attrs:{size:"5"}},[_("strong",[t._v("互斥锁")])])],1),t._v(" "),_("p",[t._v("对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。会从用户态陷入内核态，内核帮我们切换线程，会有两次线程上下文切换的成本：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；")])]),t._v(" "),_("li",[_("p",[t._v("接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。")])])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("线程的上下文切换的是什么？")]),t._v(" "),_("p",[t._v("当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。")])]),t._v(" "),_("p",[_("font",{attrs:{size:"5"}},[_("strong",[t._v("互斥锁原理：")])])],1),t._v(" "),_("p",[t._v('一般通过原子汇编指令实现，比如x86的tsl指令（test and set），可以用一条"无法继续分割的"汇编指令实现判断变量值并根据是否为0进行置位，具体这个指令实现原子性一般通过'),_("strong",[t._v("锁总线")]),t._v("实现，也就是我执行这条指令时，其它核都不能访问这个地址了，当然是原子了。这就是mutex的原子性要求的底层原理。")]),t._v(" "),_("p",[_("font",{attrs:{size:"5"}},[_("strong",[t._v("自旋锁实现原理：")])])],1),t._v(" "),_("p",[t._v("自旋锁不就是不停的while循环去获取锁，反复尝试加锁的时候，包含两个步骤：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("第一步，查看锁的状态，如果锁是空闲的，则执行第二步；")])]),t._v(" "),_("li",[_("p",[t._v("第二步，将锁设置为当前线程持有；")])])]),t._v(" "),_("p",[t._v("这个过程叫做「Compare And Swap」，简称「CAS」，它把上述两个步骤合并成一条硬件级指令，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。")]),t._v(" "),_("p",[t._v("并不意味着一直执行 CAS 函数，生产级的自旋锁在“忙等待”时，会与 CPU 紧密配合，它通过 CPU 提供的 PAUSE 指令，减少循环等待时的耗电量；PAUSE 指令通过让 CPU 休息一定的时钟周期，在此休息期间，耗电几乎停滞。")])])}),[],!1,null,null,null);v.default=p.exports}}]);