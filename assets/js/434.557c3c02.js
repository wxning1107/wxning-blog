(window.webpackJsonp=window.webpackJsonp||[]).push([[434],{1491:function(t,e,s){"use strict";s.r(e);var a=s(15),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"主从延迟问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主从延迟问题"}},[t._v("#")]),t._v(" 主从延迟问题")]),t._v(" "),s("p",[t._v("在发微博的过程中会有些同步的操作，像是更新数据库的操作，也有一些异步的操作，比如说将微博的信息同步给审核系统，所以我们在更新完主库之后，会将微博的 ID 写入消息队列，再由队列处理机依据 ID 在从库中获取微博信息再发送给审核系统。 此时如果主从数据库存在延迟，会导致在从库中获取不到微博信息，整个流程会出现异常。")]),t._v(" "),s("p",[t._v("解决方案：")]),t._v(" "),s("p",[t._v("第一种方案是数据的冗余。你可以在发送消息队列时不仅仅发送微博 ID，而是发送队列处理机需要的所有微博信息，借此避免从数据库中重新查询数据。")]),t._v(" "),s("p",[t._v("第二种方案是使用缓存。我可以在同步写数据库的同时，也把微博的数据写入到 Memcached 缓存里面，这样队列处理机在获取微博信息的时候会优先查询缓存，这样也可以保证数据的一致性。")]),t._v(" "),s("p",[t._v("最后一种方案是查询主库。不过，这种方式使用起来要慎重，要明确查询的量级不会很大。")]),t._v(" "),s("p",[t._v("我会优先考虑第一种方案，缓存的方案比较适合新增数据的场景，在更新数据的场景下，先更新缓存可能会造成数据的不一致。")])])}),[],!1,null,null,null);e.default=n.exports}}]);