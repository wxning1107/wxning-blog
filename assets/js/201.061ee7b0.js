(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{1215:function(t,e,s){"use strict";s.r(e);var T=s(15),a=Object(T.a)({},(function(){var t=this,e=t.$createElement,T=t._self._c||e;return T("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[T("h1",{attrs:{id:"简述-http-1-0-1-1-2-0-的主要区别"}},[T("a",{staticClass:"header-anchor",attrs:{href:"#简述-http-1-0-1-1-2-0-的主要区别"}},[t._v("#")]),t._v(" 简述 HTTP 1.0，1.1，2.0 的主要区别")]),t._v(" "),T("p",[t._v("HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话每次的过程总是一去一回。这样在实时性、并发性上都存在问题。")]),t._v(" "),T("p",[t._v("为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。")]),t._v(" "),T("p",[t._v("另外，HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。")]),t._v(" "),T("p",[t._v("HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有Header 帧，用于传输 Header 内容，并且会开启一个新的流。再就是Data 帧，用来传输正文实体。多个 Data 帧属于同一个流。")]),t._v(" "),T("p",[t._v("通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。")]),t._v(" "),T("p",[t._v("我们来举一个例子。")]),t._v(" "),T("p",[t._v("假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。")]),t._v(" "),T("p",[T("img",{attrs:{src:s(785),alt:"img"}})]),t._v(" "),T("p",[t._v("HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。")])])}),[],!1,null,null,null);e.default=a.exports},785:function(t,e,s){t.exports=s.p+"assets/img/image-20220325172626696.7e91261a.png"}}]);