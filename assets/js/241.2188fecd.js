(window.webpackJsonp=window.webpackJsonp||[]).push([[241],{955:function(r,e,a){"use strict";a.r(e);var _=a(15),v=Object(_.a)({},(function(){var r=this,e=r.$createElement,a=r._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"kafka幂等性、消息交付可靠性保障以及精确处理一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka幂等性、消息交付可靠性保障以及精确处理一次"}},[r._v("#")]),r._v(" Kafka幂等性、消息交付可靠性保障以及精确处理一次")]),r._v(" "),a("p",[r._v("将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 "),a("strong",[r._v("At Least Once")]),r._v(" 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 "),a("strong",[r._v("At Most Once")]),r._v(" 语义。")]),r._v(" "),a("p",[r._v("At Least Once 可以保证数据不丢失，但是不能保证数据不重复;相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 "),a("strong",[r._v("Exactly Once")]),r._v(" 语义。在 0.11 版 本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。")]),r._v(" "),a("p",[r._v("0.11 版本的 Kafka，引入了一项重大特性:"),a("strong",[r._v("幂等性")]),r._v("。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即:")]),r._v(" "),a("p",[r._v("At Least Once + 幂等性 = Exactly Once")]),r._v(" "),a("p",[r._v("要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。")]),r._v(" "),a("p",[r._v("Kafka 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对<PID, Partition, SeqNumber>做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。")]),r._v(" "),a("p",[r._v("但是 PID 重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨分区跨会话的 Exactly Once。")]),r._v(" "),a("p",[r._v("所谓的消息交付可靠性保障，是指 Kafka 对 Producer 和 Consumer 要处理的消息提供什么样的承诺。常见的承诺有以下三种：")]),r._v(" "),a("ul",[a("li",[a("p",[r._v("最多一次（at most once）：消息可能会丢失，但绝不会被重复发送。")])]),r._v(" "),a("li",[a("p",[r._v("至少一次（at least once）：消息不会丢失，但有可能被重复发送。")])]),r._v(" "),a("li",[a("p",[r._v("精确一次（exactly once）：消息不会丢失，也不会被重复发送。")])])]),r._v(" "),a("p",[r._v("目前，Kafka 默认提供的交付可靠性保障是第二种，即至少一次。只有 Broker 成功“提交”消息且 Producer 接到 Broker 的应答才会认为该消息成功发送。不过倘若消息成功“提交”，但 Broker 的应答没有成功发送回 Producer 端（比如网络出现瞬时抖动），那么 Producer 就无法确定消息是否真的提交成功了。因此，它只能选择重试，也就是再次发送相同的消息。这就是 Kafka 默认提供至少一次可靠性保障的原因，不过这会导致消息重复发送。")]),r._v(" "),a("p",[r._v("Kafka 也可以提供最多一次交付保障，只需要让 Producer 禁止重试即可。这样一来，消息要么写入成功，要么写入失败，但绝不会重复发送。我们通常不会希望出现消息丢失的情况，但一些场景里偶发的消息丢失其实是被允许的，相反，消息重复是绝对要避免的。此时，使用最多一次交付保障就是最恰当的。")]),r._v(" "),a("p",[r._v("Kafka 是怎么做到精确一次的呢？简单来说，这是通过两种机制：幂等性（Idempotence）和事务（Transaction）。")]),r._v(" "),a("h1",{attrs:{id:"幂等性-producer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幂等性-producer"}},[r._v("#")]),r._v(" 幂等性 Producer")]),r._v(" "),a("p",[r._v("幂等指的是某些操作或函数能够被执行多次，但每次得到的结果都是不变的。其最大的优势在于我们可以安全地重试任何幂等性操作，反正它们也不会破坏我们的系统状态。")]),r._v(" "),a("p",[r._v("在 Kafka 中，Producer 默认不是幂等性的，但我们可以创建幂等性 Producer。它其实是 0.11.0.0 版本引入的新功能。在此之前，Kafka 向分区发送数据时，可能会出现同一条消息被发送了多次，导致消息重复的情况。在 0.11 之后，指定 Producer 幂等性的方法很简单，仅需要设置一个参数即可，即 props.put(“enable.idempotence”, ture)。")]),r._v(" "),a("p",[r._v("Kafka 自动帮你做消息的重复去重。底层具体的原理很简单，就是经典的用空间去换时间的优化思路，即在 Broker 端多保存一些字段。当 Producer 发送了具有相同字段值的消息后，Broker 能够自动知晓这些消息已经重复了，于是可以在后台默默地把它们“丢弃”掉。当然，实际的实现原理并没有这么简单，但大致可以这么理解。")]),r._v(" "),a("p",[r._v("但是，幂等性 Producer 是有作用范围的：")]),r._v(" "),a("ul",[a("li",[a("p",[r._v("首先，它只能保证单分区上的幂等性，即一个幂等性 Producer 能够保证某个主题的一个分区上不出现重复消息，它无法实现多个分区的幂等性。")])]),r._v(" "),a("li",[a("p",[r._v("其次，它只能实现单会话上的幂等性，不能实现跨会话的幂等性。这里的会话，你可以理解为 Producer 进程的一次运行。当你重启了 Producer 进程之后，这种幂等性保证就丧失了。")])])]),r._v(" "),a("p",[r._v("那么你可能会问，如果我想实现多分区以及多会话上的消息无重复，应该怎么做呢？答案就是事务（transaction）或者依赖事务型 Producer。")]),r._v(" "),a("h1",{attrs:{id:"_1-利用数据库的唯一约束实现幂等"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-利用数据库的唯一约束实现幂等"}},[r._v("#")]),r._v(" 1.利用数据库的唯一约束实现幂等")]),r._v(" "),a("p",[r._v("例如一个不具备幂等特性的转账的例子：将账户 X 的余额加 100 元。在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。")]),r._v(" "),a("p",[r._v("首先，我们可以限定，对于每个转账单每个账户只可以执行一次变更操作，在分布式系统中，这个限制实现的方法非常多，最简单的是我们在数据库中建一张转账流水表，这个表有三个字段：转账单 ID、账户 ID 和变更金额，然后给转账单 ID 和账户 ID 这两个字段联合起来创建一个唯一约束，这样对于相同的转账单 ID 和账户 ID，表里至多只能存在一条记录。")]),r._v(" "),a("p",[r._v("这样，我们消费消息的逻辑可以变为：“在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可。”在转账流水表增加一条转账记录这个操作中，由于我们在这个表中预先定义了“账户 ID 转账单 ID”的唯一约束，对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败，这样就实现了一个幂等的操作。我们只要写一个 SQL，正确地实现它就可以了。")]),r._v(" "),a("p",[r._v("基于这个思路，不光是可以使用关系型数据库，只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如，你可以用 Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂等消费。")]),r._v(" "),a("h1",{attrs:{id:"_2-为更新的数据设置前置条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-为更新的数据设置前置条件"}},[r._v("#")]),r._v(" 2.为更新的数据设置前置条件")]),r._v(" "),a("p",[r._v("另外一种实现幂等的思路是，给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作。")]),r._v(" "),a("p",[r._v("比如，刚刚我们说过，“将账户 X 的余额增加 100 元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户 X 当前的余额为 500 元，将余额加 100 元”，这个操作就具备了幂等性。对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候进行判断数据库中，当前余额是否与消息中的余额相等，只有相等才执行变更操作。")]),r._v(" "),a("p",[r._v("但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给你的数据增加一个"),a("strong",[r._v("版本号")]),r._v("属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新。")]),r._v(" "),a("h1",{attrs:{id:"_3-记录并检查操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-记录并检查操作"}},[r._v("#")]),r._v(" 3.记录并检查操作")]),r._v(" "),a("p",[r._v("如果上面提到的两种实现幂等方法都不能适用于你的场景，我们还有一种通用性最强，适用范围最广的实现幂等性方法：记录并检查操作，也称为“Token 机制或者 GUID（全局唯一 ID）机制”，实现的思路特别简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。")]),r._v(" "),a("p",[r._v("具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。")]),r._v(" "),a("p",[r._v("原理和实现是不是很简单？其实一点儿都不简单，在分布式系统中，这个方法其实是非常难实现的。首先，给每个消息指定一个全局唯一的 ID 就是一件不那么简单的事儿，方法有很多，但都不太好同时满足简单、高可用和高性能，或多或少都要有些牺牲。更加麻烦的是，在“检查消费状态，然后更新数据并且设置消费状态”中，三个操作必须作为一组操作保证原子性，才能真正实现幂等，否则就会出现 Bug。")]),r._v(" "),a("p",[r._v("对于这个问题，当然我们可以用事务来实现，也可以用锁来实现，但是在分布式系统中，无论是分布式事务还是分布式锁都是比较难解决问题。")])])}),[],!1,null,null,null);e.default=v.exports}}]);