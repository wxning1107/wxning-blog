(window.webpackJsonp=window.webpackJsonp||[]).push([[250],{1446:function(s,e,_){"use strict";_.r(e);var a=_(15),v=Object(a.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"如何应对变慢的redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何应对变慢的redis"}},[s._v("#")]),s._v(" 如何应对变慢的Redis？")]),s._v(" "),a("h1",{attrs:{id:"_1-慢查询命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-慢查询命令"}},[s._v("#")]),s._v(" 1.慢查询命令")]),s._v(" "),a("ul",[a("li",[s._v("用其他高效命令代替。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成线程阻塞。")]),s._v(" "),a("li",[s._v("当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。")]),s._v(" "),a("li",[s._v("慢查询命令 KEYS，它用于返回和输入模式匹配的所有 key，例如，以下命令返回所有包含“name”字符串的 keys。"),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("      redis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" KEYS *name*\n      "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"lastname"')]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"firstname"')]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),s._v("因为 KEYS 命令需要遍历存储的键值对，所以操作延时高。所以，KEYS 命令一般不被建议用于生产环境中。")])]),s._v(" "),a("h1",{attrs:{id:"_2-过期-key-操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-过期-key-操作"}},[s._v("#")]),s._v(" 2.过期 key 操作")]),s._v(" "),a("p",[s._v("Redis 键值对的 key 可以设置过期时间。默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下：")]),s._v(" "),a("ul",[a("li",[s._v("采样 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个数的 key，并将其中过期的 key 全部删除；")]),s._v(" "),a("li",[s._v("如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。")])]),s._v(" "),a("p",[s._v("ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 是 Redis 的一个参数，默认是 20，那么，一秒内基本有 200 个过期 key 会被删除。这一策略对清除过期 key、释放内存空间很有帮助。如果每秒钟删除 200 个过期 key，并不会对 Redis 造成太大影响。")]),s._v(" "),a("p",[s._v("但是，如果触发了上面这个算法的第二条，Redis 就会一直删除以释放内存空间。注意，删除操作是阻塞的（Redis 4.0 后可以用异步线程机制来减少阻塞影响）。所以，一旦该条件触发，Redis 的线程就会一直执行删除，这样一来，就没办法正常服务其他的键值操作了，就会进一步引起其他键值操作的延迟增加，Redis 就会变慢。")]),s._v(" "),a("p",[s._v("那么，算法的第二条是怎么被触发的呢？其中一个重要来源，就是频繁使用带有相同时间参数的 EXPIREAT 命令设置过期 key，这就会导致，在同一秒内有大量的 key 同时过期。")]),s._v(" "),a("p",[s._v("所以要避免设置相同的过期时间。最好加上一个随机数。")]),s._v(" "),a("h1",{attrs:{id:"_3-文件系统-aof-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-文件系统-aof-模式"}},[s._v("#")]),s._v(" 3.文件系统：AOF 模式")]),s._v(" "),a("p",[s._v("AOF 日志提供的 no、everysec、always 这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。write 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘。而 fsync 需要把日志记录写回到磁盘后才能返回，时间较长。下")]),s._v(" "),a("p",[a("img",{attrs:{src:_(867),alt:"img"}})]),s._v(" "),a("p",[s._v("在使用 everysec 时，Redis 允许丢失一秒的操作记录，所以，Redis 主线程并不需要确保每个操作记录日志都写回磁盘。而且，fsync 的执行时间很长，如果是在 Redis 主线程中执行 fsync，就容易阻塞主线程。所以，"),a("strong",[s._v("当写回策略配置为 everysec 时，Redis 会使用后台的子线程异步完成 fsync 的操作。")])]),s._v(" "),a("p",[s._v("而对于 always 策略来说，Redis 需要确保每个操作记录日志都写回磁盘，如果用后台子线程异步完成，主线程就无法及时地知道每个操作是否已经完成了，这就不符合 always 策略的要求了。所以，"),a("strong",[s._v("always 策略并不使用后台子线程来执行。")])]),s._v(" "),a("p",[s._v("另外，AOF 重写机制也是使用子线程完成的，虽然 Redis 使用子进程来进行 AOF 重写，但是，这里有一个潜在的风险点：AOF 重写会对磁盘进行大量 IO 操作，同时，fsync 又需要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被阻塞。虽然 fsync 是由后台子线程负责执行的，但是，主线程会监控 fsync 的执行进度。")]),s._v(" "),a("p",[s._v("当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。所以，如果后台子线程执行的 fsync 频繁阻塞的话（比如 AOF 重写占用了大量的磁盘 IO 带宽），主线程也会阻塞，导致 Redis 性能变慢。")]),s._v(" "),a("h1",{attrs:{id:"_4-操作系统-swap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-操作系统-swap"}},[s._v("#")]),s._v(" 4.操作系统：swap")]),s._v(" "),a("p",[s._v("内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发 swap，无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。")]),s._v(" "),a("p",[s._v("正常情况下，Redis 的操作是直接通过访问内存就能完成，一旦 swap 被触发了，Redis 的请求操作需要等到磁盘数据读写完成才行。而且，swap 触发后影响的是 Redis 主 IO 线程，这会极大地增加 Redis 的响应时间。")]),s._v(" "),a("p",[s._v("我想给你分享一个我曾经遇到过的因为 swap 而导致性能降低的例子。")]),s._v(" "),a("p",[s._v("在正常情况下，我们运行的一个实例完成 5000 万个 GET 请求时需要 300s，但是，有一次，这个实例完成 5000 万 GET 请求，花了将近 4 个小时的时间。经过问题复现，我们发现，当时 Redis 处理请求用了近 4 小时的情况下，该实例所在的机器已经发生了 swap。从 300s 到 4 个小时，延迟增加了将近 48 倍，可以看到 swap 对性能造成的严重影响。")]),s._v(" "),a("p",[s._v("那么，什么时候会触发 swap 呢？")]),s._v(" "),a("p",[s._v("通常，触发 swap 的原因主要是物理机器内存不足，对于 Redis 而言，有两种常见的情况：")]),s._v(" "),a("ul",[a("li",[s._v("Redis 实例自身使用了大量的内存，导致物理机器的可用内存不足；")]),s._v(" "),a("li",[s._v("和 Redis 实例在同一台机器上运行的其他进程，在进行大量的文件读写操作。文件读写本身会占用系统内存，这会导致分配给 Redis 实例的内存量变少，进而触发 Redis 发生 swap。")])]),s._v(" "),a("p",[s._v("解决思路是增加机器的内存或者使用 Redis 集群。")]),s._v(" "),a("h1",{attrs:{id:"_5-操作系统-内存大页"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-操作系统-内存大页"}},[s._v("#")]),s._v(" 5.操作系统：内存大页")]),s._v(" "),a("p",[s._v("Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配，而常规的内存页分配是按 4KB 的粒度来执行的。")]),s._v(" "),a("p",[s._v("虽然内存大页可以在分配相同的内存量时减少分配次数，但是，Redis 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，此时，Redis 主线程仍然可以接收客户端写请求。客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，Redis 就会采用写时复制机制，也就是说，一旦有数据要被修改，Redis 并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。")]),s._v(" "),a("p",[s._v("如果采用了内存大页，那么，即使客户端请求只修改 100B 的数据，Redis 也需要拷贝 2MB 的大页。相反，如果是常规内存页机制，只用拷贝 4KB。两者相比，你可以看到，当客户端请求修改或新写入数据较多时，内存大页机制将导致大量的拷贝，这就会影响 Redis 正常的访存操作，最终导致性能变慢。")]),s._v(" "),a("p",[s._v("解决办法是关闭内存大页即可。")]),s._v(" "),a("h1",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("我给你梳理了一个包含 9 个检查点的 Checklist：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("获取 Redis 实例在当前环境下的基线性能。")])]),s._v(" "),a("li",[a("p",[s._v("是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。")])]),s._v(" "),a("li",[a("p",[s._v("是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除。")])]),s._v(" "),a("li",[a("p",[s._v("是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。")])]),s._v(" "),a("li",[a("p",[s._v("Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。")])]),s._v(" "),a("li",[a("p",[s._v("Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况。")])]),s._v(" "),a("li",[a("p",[s._v("在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。")])]),s._v(" "),a("li",[a("p",[s._v("是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。")])]),s._v(" "),a("li",[a("p",[s._v("是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。")])])])])}),[],!1,null,null,null);e.default=v.exports},867:function(s,e,_){s.exports=_.p+"assets/img/image-20211125094906640.9f4ec51b.png"}}]);