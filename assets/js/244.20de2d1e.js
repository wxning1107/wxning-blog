(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{957:function(a,t,b){"use strict";b.r(t);var e=b(15),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,b=a._self._c||t;return b("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[b("h1",{attrs:{id:"kafka和rabbitmq区别"}},[b("a",{staticClass:"header-anchor",attrs:{href:"#kafka和rabbitmq区别"}},[a._v("#")]),a._v(" kafka和rabbitMQ区别？")]),a._v(" "),b("p",[a._v("RabbitMQ 就像它的名字中的兔子一样：轻量级、迅捷，RabbitMQ 是一个相当轻量级的消息队列，非常容易部署和使用。RabbitMQ 一个比较有特色的功能是支持非常灵活的路由配置，和其他消息队列不同的是，它在生产者（Producer）和队列（Queue）之间增加了一个 Exchange 模块，你可以理解为交换机。这个 Exchange 模块的作用和交换机也非常相似，根据配置的路由规则将生产者发出的消息分发到不同的队列中。路由的规则也非常灵活，甚至你可以自己来实现路由规则。")]),a._v(" "),b("p",[a._v("RabbitMQ的几个问题：")]),a._v(" "),b("ul",[b("li",[b("p",[a._v("RabbitMQ 对消息堆积的支持并不好，在它的设计理念里面，消息队列是一个管道，大量的消息积压是一种不正常的情况，应当尽量去避免。当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。")])]),a._v(" "),b("li",[b("p",[a._v("RabbitMQ 的性能是流行的消息队列中最差的")])])]),a._v(" "),b("p",[a._v("当下的 Kafka 已经发展为一个非常成熟的消息队列产品，无论在数据可靠性、稳定性和功能特性等方面都可以满足绝大多数场景的需求。Kafka 使用 Scala 和 Java 语言开发，设计上大量使用了批量和异步的思想，这种设计使得 Kafka 能做到超高的性能。Kafka 的性能，尤其是异步收发的性能，比rabbitMQ要好")]),a._v(" "),b("p",[a._v("kafka的问题是同步收发消息的响应时延比较高，因为当客户端发送一条消息的时候，Kafka 并不会立即发送出去，而是要等一会儿攒一批再发送，在它的 Broker 中，很多地方都会使用这种“先攒一波再一起处理”的设计。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。")])])}),[],!1,null,null,null);t.default=r.exports}}]);