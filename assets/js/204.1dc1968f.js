(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{1233:function(n,t,p){"use strict";p.r(t);var s=p(15),e=Object(s.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"o-n-内求无序数组中的第k大元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#o-n-内求无序数组中的第k大元素"}},[n._v("#")]),n._v(" O(n)内求无序数组中的第K大元素")]),n._v(" "),s("p",[n._v("比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。")]),n._v(" "),s("p",[n._v("我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。")]),n._v(" "),s("p",[n._v("如果 p+1=K，那 A[p] 就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K<p+1，那我们就在 A[0…p-1] 区间查找。")]),n._v(" "),s("p",[s("img",{attrs:{src:p(588),alt:"img"}})]),n._v(" "),s("p",[n._v("我们再来看，为什么上述解决思路的时间复杂度是 O(n)？")]),n._v(" "),s("p",[n._v("第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。")]),n._v(" "),s("p",[n._v("如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。")])])}),[],!1,null,null,null);t.default=e.exports},588:function(n,t,p){n.exports=p.p+"assets/img/image-20211103132853995.1d7fd0a5.png"}}]);