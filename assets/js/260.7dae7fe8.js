(window.webpackJsonp=window.webpackJsonp||[]).push([[260],{1018:function(t,s,e){"use strict";e.r(s);var a=e(15),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"缓存的类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存的类型"}},[t._v("#")]),t._v(" 缓存的类型")]),t._v(" "),e("h1",{attrs:{id:"只读缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#只读缓存"}},[t._v("#")]),t._v(" 只读缓存")]),t._v(" "),e("p",[t._v("当 Redis 用作只读缓存时，应用要读取数据的话，会先调用 Redis GET 接口，查询数据是否存在。而所有的数据写请求，会直接发往后端的数据库，在数据库中增删改。对于删改的数据来说，如果 Redis 已经缓存了相应的数据，应用需要把这些缓存的数据删除，Redis 中就没有这些数据了。")]),t._v(" "),e("p",[t._v("当应用再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中。")]),t._v(" "),e("h1",{attrs:{id:"读写缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#读写缓存"}},[t._v("#")]),t._v(" 读写缓存")]),t._v(" "),e("p",[t._v("对于读写缓存来说，除了读请求会发送到缓存进行处理，所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。")]),t._v(" "),e("p",[t._v("但是，和只读缓存不一样的是，在使用读写缓存时，最新的数据是在 Redis 中，而 Redis 是内存数据库，一旦出现掉电或宕机，内存中的数据就会丢失。")]),t._v(" "),e("p",[t._v("所以，根据业务应用对数据可靠性和缓存性能的不同要求，我们会有同步直写和异步写回两种策略。")]),t._v(" "),e("p",[t._v("同步直写是指，写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。不过，同步直写会降低缓存的访问性能。")]),t._v(" "),e("p",[t._v("而异步写回策略，则是优先考虑了响应延迟。此时，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。这样一来，处理这些数据的操作是在缓存中进行的，很快就能完成。只不过，如果发生了掉电，而它们还没有被写回数据库，就会有丢失的风险了。")])])}),[],!1,null,null,null);s.default=r.exports}}]);