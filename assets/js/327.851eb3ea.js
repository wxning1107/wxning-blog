(window.webpackJsonp=window.webpackJsonp||[]).push([[327],{1282:function(r,e,o){"use strict";o.r(e);var t=o(15),s=Object(t.a)({},(function(){var r=this,e=r.$createElement,o=r._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[o("h1",{attrs:{id:"检测消息丢失的方法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#检测消息丢失的方法"}},[r._v("#")]),r._v(" 检测消息丢失的方法")]),r._v(" "),o("p",[r._v("我们可以利用消息队列的有序性来验证是否有消息丢失。原理非常简单，在 Producer 端，我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的连续性。如果没有消息丢失，Consumer 收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号 +1。如果检测到序号不连续，那就是丢消息了。")]),r._v(" "),o("p",[r._v("大多数消息队列的客户端都支持拦截器机制，可以利用这个拦截器机制，在 Producer 发送消息之前的拦截器中将序号注入到消息中，在 Consumer 收到消息的拦截器中检测序号的连续性。")]),r._v(" "),o("p",[r._v("有几个问题需要注意：")]),r._v(" "),o("p",[r._v("首先，像 Kafka 和 RocketMQ 这样的消息队列，它是不保证在 Topic 上的严格顺序的，只能保证分区上的消息是有序的，所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。")]),r._v(" "),o("p",[r._v("如果你的系统中 Producer 是多实例的，由于并不好协调多个 Producer 之间的发送顺序，所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性。")]),r._v(" "),o("p",[r._v("Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性。")])])}),[],!1,null,null,null);e.default=s.exports}}]);