(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{1008:function(a,s,t){"use strict";t.r(s);var e=t(15),v=Object(e.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"散列冲突-开放寻址法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#散列冲突-开放寻址法"}},[a._v("#")]),a._v(" 散列冲突---开放寻址法")]),a._v(" "),e("p",[a._v("再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。")]),a._v(" "),e("p",[a._v("这两种冲突解决办法在实际的软件开发中都非常常用。"),e("strong",[a._v("Java")]),a._v(" 中 LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。")]),a._v(" "),e("p",[a._v("开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？我先讲一个比较简单的探测方法，"),e("strong",[a._v("线性探测")]),a._v("（Linear Probing）。")]),a._v(" "),e("p",[a._v("当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。")]),a._v(" "),e("p",[a._v("下面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(556),alt:"img"}})]),a._v(" "),e("p",[a._v("从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。")]),a._v(" "),e("p",[a._v("在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(557),alt:"img"}})]),a._v(" "),e("p",[a._v("散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？")]),a._v(" "),e("p",[a._v("还记得我们刚讲的查找操作吗？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？")]),a._v(" "),e("p",[a._v("我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。")]),a._v(" "),e("p",[e("img",{attrs:{src:t(558),alt:"img"}})]),a._v(" "),e("p",[a._v("你可能已经发现了，线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。")]),a._v(" "),e("p",[a._v("对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，"),e("strong",[a._v("二次探测")]),a._v("（Quadratic probing）和"),e("strong",[a._v("双重散列")]),a._v("（Double hashing）。")]),a._v(" "),e("p",[a._v("所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……")]),a._v(" "),e("p",[a._v("所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。")]),a._v(" "),e("p",[a._v("不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用"),e("strong",[a._v("装载因子")]),a._v("（load factor）来表示空位的多少。")]),a._v(" "),e("h1",{attrs:{id:"装载因子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#装载因子"}},[a._v("#")]),a._v(" 装载因子")]),a._v(" "),e("p",[a._v("装载因子的计算公式是：")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("散列表的装载因子 = 填入表中的元素个数 / 散列表的长度\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。")]),a._v(" "),e("h1",{attrs:{id:"开放寻址法的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开放寻址法的优点"}},[a._v("#")]),a._v(" 开放寻址法的优点")]),a._v(" "),e("p",[a._v("开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。")]),a._v(" "),e("p",[e("strong",[a._v("开放寻址法的缺点")])]),a._v(" "),e("p",[a._v("用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。")]),a._v(" "),e("p",[e("strong",[a._v("我总结一下，当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因")]),a._v("。")])])}),[],!1,null,null,null);s.default=v.exports},556:function(a,s,t){a.exports=t.p+"assets/img/image-20211103184841300.deb0eb57.png"},557:function(a,s,t){a.exports=t.p+"assets/img/image-20211103184944361.53b03d79.png"},558:function(a,s,t){a.exports=t.p+"assets/img/image-20211103185052798.d21b692e.png"}}]);