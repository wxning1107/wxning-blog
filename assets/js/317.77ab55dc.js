(window.webpackJsonp=window.webpackJsonp||[]).push([[317],{1110:function(e,t,r){"use strict";r.r(t);var i=r(15),v=Object(i.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"trie树与散列表、红黑树的比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#trie树与散列表、红黑树的比较"}},[e._v("#")]),e._v(" Trie树与散列表、红黑树的比较")]),e._v(" "),r("p",[e._v("实际上，字符串的匹配问题，笼统上讲，其实就是数据的查找问题。对于支持动态数据高效操作的数据结构，我们前面已经讲过好多了，比如散列表、红黑树、跳表等等。实际上，这些数据结构也可以实现在一组字符串中查找字符串的功能。我们选了两种数据结构，散列表和红黑树，跟 Trie 树比较一下，看看它们各自的优缺点和应用场景。")]),e._v(" "),r("p",[e._v("在刚刚讲的这个场景，在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。")]),e._v(" "),r("p",[e._v("第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。")]),e._v(" "),r("p",[e._v("第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。")]),e._v(" "),r("p",[e._v("第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。")]),e._v(" "),r("p",[e._v("第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。")]),e._v(" "),r("p",[e._v("综合这几点，针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。")]),e._v(" "),r("p",[e._v("实际上，Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串。")])])}),[],!1,null,null,null);t.default=v.exports}}]);