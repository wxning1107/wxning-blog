(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{451:function(t,s,e){t.exports=e.p+"assets/img/image-20211103202845401.13e907f0.png"},775:function(t,s,e){"use strict";e.r(s);var a=e(15),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"如何避免低效地扩容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免低效地扩容"}},[t._v("#")]),t._v(" 如何避免低效地扩容？")]),t._v(" "),a("p",[t._v("装载因子过大了怎么办？")]),t._v(" "),a("p",[t._v("针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。")]),t._v(" "),a("p",[t._v("大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。")]),t._v(" "),a("p",[t._v("为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。")]),t._v(" "),a("p",[t._v("当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(451),alt:"img"}})]),t._v(" "),a("p",[t._v("对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。")]),t._v(" "),a("p",[t._v("通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。")])])}),[],!1,null,null,null);s.default=n.exports}}]);