(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{1278:function(s,t,e){"use strict";e.r(t);var a=e(15),n=Object(a.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"什么是幻读-怎么解决幻读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是幻读-怎么解决幻读"}},[s._v("#")]),s._v(" 什么是幻读？怎么解决幻读？")]),s._v(" "),a("p",[s._v("假设有这样一张表：")]),s._v(" "),a("div",{staticClass:"language-mysql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("CREATE TABLE `t` (\n  `id` int(11) NOT NULL,\n  `c` int(11) DEFAULT NULL,\n  `d` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `c` (`c`)\n) ENGINE=InnoDB;\n \ninsert into t values(0,0,0),(5,5,5),\n(10,10,10),(15,15,15),(20,20,20),(25,25,25);\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("来看一下这个场景: 假设只在 id=5 这一行加锁，而其他行的不加锁")]),s._v(" "),a("p",[a("img",{attrs:{src:e(522),alt:"img"}})]),s._v(" "),a("p",[s._v("可以看到，session A 里执行了三次查询，查询结果都不相同。其中，Q3 读到 id=1 这一行的现象，被称为“幻读”。"),a("strong",[s._v("幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。")])]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),a("ul",[a("li",[s._v("在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。")]),s._v(" "),a("li",[s._v("上面 session B 的修改结果，被 session A 之后的 select 语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。")])])]),s._v(" "),a("h1",{attrs:{id:"幻读产生的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幻读产生的原因"}},[s._v("#")]),s._v(" 幻读产生的原因")]),s._v(" "),a("p",[a("img",{attrs:{src:e(523),alt:"img"}})]),s._v(" "),a("p",[s._v("为什么我们已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了 id=1 这一行的插入和更新呢？")]),s._v(" "),a("p",[s._v("原因很简单。在 T3 时刻，我们给所有行加锁的时候，id=1 这一行还不存在，不存在也就加不上锁。")]),s._v(" "),a("p",[s._v("也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻读”会被单独拿出来解决的原因。")]),s._v(" "),a("h1",{attrs:{id:"如何解决幻读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解决幻读"}},[s._v("#")]),s._v(" 如何解决幻读？")]),s._v(" "),a("p",[s._v("产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。")]),s._v(" "),a("p",[s._v("顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。")]),s._v(" "),a("p",[a("img",{attrs:{src:e(524),alt:"img"}})]),s._v(" "),a("p",[s._v("这样，当你执行 select * from t where d=5 for update 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。")]),s._v(" "),a("p",[s._v("也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。")]),s._v(" "),a("p",[a("strong",[s._v("跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。")]),s._v(" 间隙锁之间都不存在冲突关系。")]),s._v(" "),a("p",[s._v("这句话不太好理解，我给你举个例子：")]),s._v(" "),a("p",[a("img",{attrs:{src:e(525),alt:"img"}})]),s._v(" "),a("p",[s._v("这里 session B 并不会被堵住。因为表 t 里并没有 c=7 这个记录，因此 session A 加的是间隙锁 (5,10)。而 session B 也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。")]),s._v(" "),a("p",[s._v("间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。")]),s._v(" "),a("p",[s._v("间隙锁的缺点：")]),s._v(" "),a("p",[a("strong",[s._v("间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。")]),s._v(" 甚至出现由于间隙锁导致的死锁现象。")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),a("p",[s._v("有一种说法：当两次快照读之间存在当前读，ReadView会重新生成，导致产生幻读。来源："),a("a",{attrs:{href:"https://www.bilibili.com/video/BV1hL411479T/?spm_id_from=333.788",target:"_blank",rel:"noopener noreferrer"}},[s._v("这可能是最直白的MySQL MVCC机制讲解啦!"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports},522:function(s,t,e){s.exports=e.p+"assets/img/image-20220307091519223.fc2111cc.png"},523:function(s,t,e){s.exports=e.p+"assets/img/image-20220307093013273.d661683e.png"},524:function(s,t,e){s.exports=e.p+"assets/img/image-20220307093345468.27e52dbc.png"},525:function(s,t,e){s.exports=e.p+"assets/img/image-20220307093655228.c19ef076.png"}}]);