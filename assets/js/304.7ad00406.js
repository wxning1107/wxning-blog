(window.webpackJsonp=window.webpackJsonp||[]).push([[304],{1065:function(e,t,r){"use strict";r.r(t);var s=r(15),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"字典-hash"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字典-hash"}},[e._v("#")]),e._v(" 字典（hash）")]),e._v(" "),r("p",[e._v("字典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是我们刚刚讲到的"),r("strong",[e._v("压缩列表")]),e._v("，另一种是"),r("strong",[e._v("散列表")]),e._v("。")]),e._v(" "),r("p",[e._v("同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：")]),e._v(" "),r("ul",[r("li",[e._v("字典中保存的键和值的大小都要小于 64 字节；")]),e._v(" "),r("li",[e._v("字典中键值对的个数要小于 512 个。")])]),e._v(" "),r("p",[e._v("当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。Redis 使用"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C",target:"_blank",rel:"noopener noreferrer"}},[e._v("MurmurHash2"),r("OutboundLink")],1),e._v("这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容。")]),e._v(" "),r("p",[e._v("当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右（具体值需要计算才能得到，如果感兴趣，你可以去阅读"),r("a",{attrs:{href:"https://github.com/antirez/redis/blob/unstable/src/dict.c",target:"_blank",rel:"noopener noreferrer"}},[e._v("源码"),r("OutboundLink")],1),e._v("）。")]),e._v(" "),r("p",[e._v("当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小（这个值也是计算得到的，如果感兴趣，你也可以去阅读"),r("a",{attrs:{href:"https://github.com/antirez/redis/blob/unstable/src/dict.c",target:"_blank",rel:"noopener noreferrer"}},[e._v("源码"),r("OutboundLink")],1),e._v("）。")]),e._v(" "),r("p",[e._v("我们前面讲过，扩容缩容要做大量的数据搬移和哈希值的重新计算，所以比较耗时。针对这个问题，Redis 使用我们在散列表那章中讲的渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。")])])}),[],!1,null,null,null);t.default=n.exports}}]);