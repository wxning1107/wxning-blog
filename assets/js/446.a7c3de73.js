(window.webpackJsonp=window.webpackJsonp||[]).push([[446],{1530:function(t,s,e){"use strict";e.r(s);var n=e(15),r=Object(n.a)({},(function(){var t=this.$createElement,s=this._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[s("h1",{attrs:{id:"消费线程空转的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费线程空转的问题"}},[this._v("#")]),this._v(" 消费线程空转的问题")]),this._v(" "),s("p",[this._v("我是最初在测试自己写的一个消息中间件的时候发现的。当时，我发现运行消费客户端的进程会偶发地出现 CPU 跑满的情况，于是打印了 JVM 线程堆栈，找到了那个跑满 CPU 的线程。这个时候才发现，原来是消息队列中，有一段时间没有新的消息，于是消费客户端拉取不到新的消息就会不间断地轮询拉取消息，这个线程就把 CPU 跑满了。所以，你在写消费客户端的时候要考虑这种场景，拉取不到消息可以等待一段时间再来拉取，等待的时间不宜过长，否则会增加消息的延迟。我一般建议固定的 10ms~100ms，也可以按照一定步长递增，比如第一次拉取不到消息等待 10ms，第二次 20ms，最长可以到 100ms，直到拉取到消息再回到 10ms。")])])}),[],!1,null,null,null);s.default=r.exports}}]);