(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{1144:function(e,r,a){"use strict";a.r(r);var s=a(15),t=Object(s.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"kafka如何解决消息丢失问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka如何解决消息丢失问题"}},[e._v("#")]),e._v(" Kafka如何解决消息丢失问题")]),e._v(" "),s("p",[e._v("一句话概括，Kafka 只对“已提交”的消息（committed message）做有限度的持久化保证。")]),e._v(" "),s("h1",{attrs:{id:"生产者丢失消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产者丢失消息"}},[e._v("#")]),e._v(" 生产者丢失消息")]),e._v(" "),s("p",[e._v("目前 Kafka Producer 是异步发送消息的，也就是说如果你调用的是 producer.send(msg) 这个 API，那么它通常会立即返回，但此时你不能认为消息发送已成功完成。Producer 永远要使用带有回调通知的发送 API，也就是说不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。不要小瞧这里的 callback（回调），它能准确地告诉你消息是否真的提交成功了。一旦出现消息提交失败的情况，你就可以有针对性地进行处理。")]),e._v(" "),s("h1",{attrs:{id:"消费者丢失消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费者丢失消息"}},[e._v("#")]),e._v(" 消费者丢失消息")]),e._v(" "),s("p",[e._v("先消费消息，再更新位移的顺序，这样就能最大限度地保证消息不丢失。")]),e._v(" "),s("p",[e._v("如果是多线程异步处理消费消息，Consumer 程序不要开启自动提交位移，而是要应用程序手动提交位移。")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("提醒")]),e._v(" "),s("p",[e._v("在这里我要提醒你一下，单个 Consumer 程序使用多线程来消费消息说起来容易，写成代码却异常困难，因为你很难正确地处理位移的更新，也就是说避免无消费消息丢失很简单，但极易出现消息被消费了多次的情况。")])]),e._v(" "),s("h1",{attrs:{id:"最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[e._v("#")]),e._v(" 最佳实践")]),e._v(" "),s("p",[e._v("1.不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。")]),e._v(" "),s("p",[e._v("2.设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。")]),e._v(" "),s("p",[e._v("3.设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries > 0 的 Producer 能够自动重试消息发送，避免消息丢失。")]),e._v(" "),s("p",[e._v("4.设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。")]),e._v(" "),s("p",[e._v("5.设置 replication.factor >= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。")]),e._v(" "),s("p",[e._v("6.设置 min.insync.replicas > 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。")]),e._v(" "),s("p",[e._v("7.确保 replication.factor > min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。")]),e._v(" "),s("p",[e._v("8.确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。")]),e._v(" "),s("p",[s("img",{attrs:{src:a(468),alt:"img"}})])])}),[],!1,null,null,null);r.default=t.exports},468:function(e,r,a){e.exports=a.p+"assets/img/image-20220321175533995.fe71507c.png"}}]);