# 垃圾回收机制

# GC触发时机

**阀值触法：**

垃圾回收的触发是由一个gcpercent的变量控制的，当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如，gcpercent=100，当前使用了4M的内存，那么当内存分配到达8M时就会再次gc。如果回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高，这个算法使得垃圾回收的频率比较稳定，适合应用的场景。

gcpercent的值是通过环境变量`GOGC`获取的，如果不设置这个环境变量，默认值是100。如果将它设置成off，则是关闭垃圾回收。


**定期触法：**

默认情况下，最长2分钟触发一次GC，这个间隔在`src/runtime/proc.go:forcegcperiod`变量中被声明：

```go
// forcegcperiod is the maximum time in nanoseconds between garbage
// collections. If we go this long without a garbage collection, one
// is forced to run.
//
// This is a variable for testing purposes. It normally doesn't change.
var forcegcperiod int64 = 2 * 60 * 1e9
```


**手动触法：**

程序代码中也可以使用`runtime.GC()`来手动触发GC。这主要用于GC性能测试和统计。



# 标记清除法缺点？

- STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**；
  
- 标记需要扫描整个heap；
  
- 清除数据会产生heap碎片。

参考：[aceld博客文章](https://www.kancloud.cn/aceld/golang/1958308)



# 强三色不变式和弱三色不变式


强三色不变式：强制不允许黑色对象引用白色对象

弱三色不变式：黑色对象可以引用白色对象，但是需要白色对象存在其他灰色对象堆它的引用，或者可达它的链路上游存在灰色对象


# 插入写屏障和删除写屏障

**插入写屏障：**

在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)，满足**强三色不变式**. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)

```
添加下游对象(当前下游对象slot, 新下游对象ptr) {   
  //1
  标记灰色(新下游对象ptr)   
  
  //2
  当前下游对象slot = 新下游对象ptr  				  
}
```

由于栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在**栈空间的对象操作中不使用**. 而仅仅使用在堆空间对象的操作中。所以在准备回收白色前，重新扫描一次栈空间，此时加`STW`暂停保护栈防止外界干扰（有新的白色被黑色添加），这次STW大约的时间在10~100ms间。

**参考：**[aceld博客文章](https://www.kancloud.cn/aceld/golang/1958308)



**删除写屏障：**

被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。满足**弱三色不变式**. (保护灰色对象到白色对象的路径不会断)

```
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
  		标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
  }
  
  //2
  当前下游对象slot = 新下游对象ptr
}
```

这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。



# 混合写屏障

1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，

2、GC期间，任何在栈上创建的新对象，均为黑色。

3、被删除的对象标记为灰色。

4、被添加的对象标记为灰色。



栈上不启用屏障，最初全部被标记为黑色，堆上启用屏障



# 辅助GC(Mutator Assist)

为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮助GC做一部分工作，这个机制叫作Mutator Assist。

