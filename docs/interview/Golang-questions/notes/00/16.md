# 协程非抢占式多任务处理讲一下？

线程在任何时候都会被操作系统切换，所以线程是抢占式多任务处理，线程没有控制权的，哪怕做到一半甚至是语句执行到一半都会被操作系统从中间掐掉然后转到其他线程上去做。协程不一样，协程是非抢占式的，什么时候交出控制权是由协程内部决定的，正是由于非抢占式才使得协程变得轻量级，抢占式需要处理保存上一个线程更多的上下文，对资源消耗多一些，说白了就是线程的切换比协程需要保存的上下文更多。协程是编译器/解释器/虚拟机层面的多任务，不是操作系统层面的多任务，go语言自己的调度器调度协程而不需要操作系统调度器，因此多个协程可以在一个线程上执行。

虽然goroutine是非抢占式的，但是gmp调度器还是可以对协程进行切换。

goroutine可能切换的点：

- I/O，select
  
- channel
  
- 等待锁
  
- 函数调用 （有时）
  
- runtime.GoSched()


来源：ccmouse goroutine