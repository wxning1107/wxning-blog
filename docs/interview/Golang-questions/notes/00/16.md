# 协程非抢占式多任务处理讲一下？

<video id="video" width="1000px" height="600px" controls="controls">
    <source id="mp4" src="./assets/videos/抢占式调度(1).mp4" type="video/mp4">
</video>

<video id="video" width="1000px" height="600px" controls="controls">
    <source id="mp4" src="./assets/videos/抢占式调度(2).mp4" type="video/mp4">
</video>

线程在任何时候都会被操作系统切换，所以线程是抢占式多任务处理，线程没有控制权的，哪怕做到一半甚至是语句执行到一半都会被操作系统从中间掐掉然后转到其他线程上去做。协程不一样，协程是非抢占式的，什么时候交出控制权是由协程内部决定的，正是由于非抢占式才使得协程变得轻量级，抢占式需要处理保存上一个线程更多的上下文，对资源消耗多一些，说白了就是线程的切换比协程需要保存的上下文更多。协程是编译器/解释器/虚拟机层面的多任务，不是操作系统层面的多任务，go语言自己的调度器调度协程而不需要操作系统调度器，因此多个协程可以在一个线程上执行。

虽然goroutine是非抢占式的，但是gmp调度器还是可以对协程进行切换。

goroutine可能切换的点：

- I/O，select
  
- channel
  
- 等待锁
  
- 函数调用 （有时）
  
- runtime.GoSched()


来源：ccmouse goroutine


# go 1.13

gc的stw逻辑是gc需要抢占所有的p，将当前的p、陷入系统调用的p、空闲的p设置为_Pgcstop状态，对于还有g在运行的p，设置g.stackguard0=stackPreempt，并且设置一个gcwaiting标识。未防止栈溢出，编译器会在有明显栈消耗的函数头部插入一些检验代码，对于g.stackguard0=stackPreempt的g并不会执行栈增长函数，而是去执一次调度函数（schedule()），在schedule函数里检测到gcwaiting标识然后会让出当前p，将其设置为_Pgstop状态，这就是协作式抢占，。所以像for{}这种没有函数调用的阻塞并不会执行栈增长检测代码自然不会让出cpu。

参考：[幼麟实验室](https://zhuanlan.zhihu.com/p/386998235)

# go 1.14 基于信号实现异步抢占

抢占流程由抢占的发起方向被抢占线程发送 SIGURG 信号。

抢占会在下列时机发生：

- STW 期间
  
- 在 P 上执行 safe point 函数期间
  
- sysmon 后台监控期间

- gc pacer 分配新的 dedicated worker 期间

- panic 崩溃期间

runtime.signalM函数向指定m发送sigPreempt信号，线程接收到信号以后，将g的执行上下文注入异步抢占函数，这个函数最终会调用schedule函数。即使for{}没有执行栈增长检测代码，通过注入异步回调函数的方式，依然不会阻塞，实现抢占式调度。

参考：

- [幼麟实验室](https://zhuanlan.zhihu.com/p/387003228)

- [csdn文章](https://blog.csdn.net/cch1234/article/details/119113759)

