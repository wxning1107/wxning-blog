# string和[]byte的转换原理

<font size=5>**byte类型**</font>


我们看一下官方对byte的定义：

``` go
// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8
```

我们可以看到byte就是uint8的别名，它是用来区分字节值和8位无符号整数值。其实可以把byte当作一个ASCII码的一个字符。示例：

``` go
var ch byte = 65
var ch byte = '\x41'
var ch byte = 'A'
```

<font size=5>**[]byte类型**</font>

[]byte就是一个byte类型的切片，切片本质也是一个结构体，定义如下：

``` go
// src/runtime/slice.go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

<font size=5>**string类型**</font>

先来看一下string的官方定义：

``` go
// string is the set of all strings of 8-bit bytes, conventionally but not
// necessarily representing UTF-8-encoded text. A string may be empty, but
// not nil. Values of string type are immutable.
type string string
```

string是一个8位字节的集合，通常但不一定代表UTF-8编码的文本。string可以为空，但是不能为nil。**string的值是不能改变的。**

string类型本质也是一个结构体，定义如下：

``` go
type stringStruct struct {
    str unsafe.Pointer
    len int
}
```

<font size=5>**string和[]byte区别**</font>

上面我们一起分析了string类型，其实他底层本质就是一个byte类型的数组，那么问题就来了，string类型为什么还要在数组的基础上再进行一次封装呢？

这是因为在Go语言中string类型被设计为不可变的，不仅是在Go语言，其他语言中string类型也是被设计为不可变的，这样的好处就是：在并发场景下，我们可以在不加锁的控制下，多次使用同一字符串，在保证高效共享的情况下而不用担心安全问题。

string类型虽然是不能更改的，但是可以被替换，因为stringStruct中的str指针是可以改变的，只是指针指向的内容是不可以改变的。

<font size=5>**string和[]byte标准转换**</font>

``` go
func main()  {
    str := "asong"
    by := []byte(str)

    str1 := string(by)
    fmt.Println(str1)
}
```

我们对上面的代码执行如下指令go tool compile -N -l -S ./string_to_byte/string.go，可以看到调用的是runtime.stringtoslicebyte：

``` go
// runtime/string.go go 1.15.7
const tmpStringBufSize = 32

type tmpBuf [tmpStringBufSize]byte

func stringtoslicebyte(buf *tmpBuf, s string) []byte {
    var b []byte
    if buf != nil && len(s) <= len(buf) {
        *buf = tmpBuf{}
        b = buf[:len(s)]
    } else {
        b = rawbyteslice(len(s))
    }
    copy(b, s)
    return b
}
// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.
func rawbyteslice(size int) (b []byte) {
    cap := roundupsize(uintptr(size))
    p := mallocgc(cap, nil, false)
    if cap != uintptr(size) {
        memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))
    }

    *(*slice)(unsafe.Pointer(&b)) = slice{p, size, int(cap)}
    return
}
```

这里分了两种状况，通过字符串长度来决定是否需要重新分配一块内存。也就是说预先定义了一个长度为32的数组，字符串的长度超过了这个数组的长度，就说明[]byte不够用了，需要重新分配一块内存了。这也算是一种优化吧，**32是阈值，只有超过32才会进行内存分配。**

最后我们会通过调用copy方法实现string到[]byte的拷贝，具体实现在src/runtime/slice.go中的slicestringcopy方法，这段代码的核心思路就是：**将string的底层数组从头部复制n个到[]byte对应的底层数组中去**。

[]byte类型转换到string类型本质调用的就是runtime.slicebytetostring：

``` go
// 以下无关的代码片段
func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) {
    if n == 0 {
        return ""
    }
    if n == 1 {
        p := unsafe.Pointer(&staticuint64s[*ptr])
        if sys.BigEndian {
            p = add(p, 7)
        }
        stringStructOf(&str).str = p
        stringStructOf(&str).len = 1
        return
    }

    var p unsafe.Pointer
    if buf != nil && n <= len(buf) {
        p = unsafe.Pointer(buf)
    } else {
        p = mallocgc(uintptr(n), nil, false)
    }
    stringStructOf(&str).str = p
    stringStructOf(&str).len = n
    memmove(p, unsafe.Pointer(ptr), uintptr(n))
    return
}
```

这段代码我们可以看出会根据[]byte的长度来决定是否重新分配内存，最后通过memove可以拷贝数组到字符串。(这里似乎是这样的：byte切片长度为0直接返回，为1不拷贝内存，其余情况才会拷贝)

<font size=5>**string和[]byte强转换**</font>

为了减少内存拷贝和内存申请我们可以使用强转换的方式对两者进行转换。在标准库中有对这两种方法实现：

``` go
// runtime/string.go
func slicebytetostringtmp(ptr *byte, n int) (str string) {
    stringStructOf(&str).str = unsafe.Pointer(ptr)
    stringStructOf(&str).len = n
    return
}

func stringtoslicebytetmp(s string) []byte {
    str := (*stringStruct)(unsafe.Pointer(&s))
    ret := slice{array: unsafe.Pointer(str.str), len: str.len, cap: str.len}
    return *(*[]byte)(unsafe.Pointer(&ret))
}
```

通过这两个方法我们可知道，主要使用的就是unsafe.Pointer进行指针替换，为什么这样可以呢？因为string和slice的结构字段是相似的：

``` go
type stringStruct struct {
    str unsafe.Pointer
    len int
}
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

唯一不同的就是cap字段，array和str是一致的，len是一致的，所以他们的内存布局上是对齐的，这样我们就可以直接通过unsafe.Pointer进行指针替换。

<font size=5>**两种转换如何取舍**</font>

当然是推荐大家使用标准转换方式了，毕竟标准转换方式是更安全的！但是如果你是在高性能场景下使用，是可以考虑使用强转换的方式的，但是要注意强转换的使用方式，他不是安全的，这里举个例子：

``` go
func stringtoslicebytetmp(s string) []byte {
    str := (*reflect.StringHeader)(unsafe.Pointer(&s))
    ret := reflect.SliceHeader{Data: str.Data, Len: str.Len, Cap: str.Len}
    return *(*[]byte)(unsafe.Pointer(&ret))
}

func main()  {
    str := "hello"
    by := stringtoslicebytetmp(str)
    by[0] = 'H'
}
```

运行结果：

``` go
unexpected fault address 0x109d65f
fatal error: fault
[signal SIGBUS: bus error code=0x2 addr=0x109d65f pc=0x107eabc]
```

我们可以看到程序直接发生严重错误了，即使使用defer+recover也无法捕获。原因是什么呢？

我们前面介绍过，string类型是不能改变的，也就是底层数据是不能更改的，这里因为我们使用的是强转换的方式，那么by指向了str的底层数组，现在对这个数组中的元素进行更改，就会出现这个问题，导致整个程序down掉！



参考：

- [Golang梦工厂](https://segmentfault.com/a/1190000040289417?utm_source=sf-hot-article)