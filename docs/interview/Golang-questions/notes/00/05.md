# 数组和切片的区别？

数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。数组是值类型，在初始化后长度是固定的，无法修改其长度。当作为方法的参数传入时将复制一份数组而不是引用同一指针。数组的长度也是其类型的一部分，通过内置函数len(array)获取其长度。由于数组的长度是数组类型的一部分，所以[3]int 和 [4]int 是两种不同的数组类型。因此在Go语言中很少直接使用数组（不同长度的数组因为类型不同无法直接赋值）

但是切片呢，切片表示一个拥有相同类型元素的可变长度的序列。简单来说切片是一个动态数组。切片的长度是不固定的。

切片是一种轻量级的数据结构，它有三个属性：指针、长度和容量。切片是饮引用传递。切片可以通过数组来初始化，也可以通过内置函数make()初始化，初始化时len=cap,在追加元素时如果容量cap不足时将扩容。

从底层角度讲：

```go
type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
```

一个slice是一个数组某个部分的引用。在内存中，它是一个包含3个域的结构体：指向slice中第一个元素的指针，slice的长度，以及slice的容量。长度是下标操作的上界，如x[i]中i必须小于长度。容量是分割操作的上界，如x[i:j]中j不能大于容量。

数组的slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。 如同分割一个字符串，分割数组也不涉及复制操作：它只是新建了一个结构来放置一个不同的指针，长度和容量。

# slice 扩容策略

在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：

1.如果期望容量大于当前容量的两倍就会使用期望容量；

2.如果当前切片的长度小于 1024 就会将容量翻倍；

3.如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；


::: tip 注意
上面只是确定大致容量，源码中还需要根据切片中的元素大小对齐内存减少碎片。

具体可看：[draveness源码阅读](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/#324-%E8%BF%BD%E5%8A%A0%E5%92%8C%E6%89%A9%E5%AE%B9)
:::



# 总结：

- 每个切片都指向一个底层数组
  
- 每个切片都保存了当前切片的长度、底层数组可用容量
  
- 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片
  
- 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片
  
- 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣
  
- 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片