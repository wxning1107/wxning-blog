# 索引

# InnoDB 的索引模型

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。

非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。

# 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。新插入数据时可能会导致挪动后面的数据，而更糟的情况是，如果所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。

# 为什么推荐使用自增主键？

自增主键的插入数据模式，符合递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**

所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：

- 只有一个索引；

- 该索引必须是唯一索引。

你一定看出来了，这就是典型的 KV 场景。

由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

# 覆盖索引

如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

# 最左前缀原则

B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。


# 在建立联合索引的时候，如何安排索引内的字段顺序。

这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。

这时候，我们要考虑的原则就是空间了。比如 name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。

::: tip 提示

联合索引与where条件的顺序无关，where a=1 and b=2 和 where b=2 and a=1都会使用（a,b）联合索引。 

:::


# 索引下推

我们以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：

```mysql
select * from tuser where name like '张 %' and age=10 and ismale=1;
```

你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。

然后呢？

当然是判断其他条件是否满足。

在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。即，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。减少回表次数。


# 索引失效场景

<font size=5>**条件字段函数操作**</font>


例如：统计发生在所有年份中 7 月份的交易记录总数
``` mysql
mysql> select count(*) from tradelog where month(t_modified)=7;
```

<font size=5>**隐式类型转换**</font>


tradeid 的字段类型是 varchar(32)，而输入的参数却是整型，所以需要做类型转换:
``` mysql
mysql> select * from tradelog where tradeid=110717;
```

<font size=5>**隐式字符编码转换**</font>


utf8mb4 与 utf8 字符集转换


<font size=5>**其他索引失效场景**</font>


![img](./assets/image-20220313201542668.png)

# 什么时候不适合建索引?

**哪些情况下不适合建索引?**

- 经常增删改的表的字段不适合建立索引（索引提高了查询的速度，同时却会降低更新表的速度，因为建立索引后, 如果对表进行INSERT,UPDATE和DELETE, MYSQL不仅要保存数据，还要保存一下索引文件）

- 表记录太少

- where条件中用不到的字段不适合建立索引

- 表数据可以确定比较少的不需要建索引

- 数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值

- 参与列计算的列不适合建索引

<br></br>


**哪些情况下适合建索引?**

- 主键自动建立唯一索引。

- 频繁作为where条件语句查询的字段

- 关联字段需要建立索引，例如外键字段，student表中的classid,   classes表中的schoolid 等

- 排序字段可以建立索引

- 分组字段可以建立索引，因为分组的前提是排序

- 统计字段可以建立索引，例如count(),max()

****

索引设计原则：

1、适合索引的列是出现在where字句中的列，或者连接子句中指定的列

2、基数较小的表（比如性别，基数只有男，女），索引效果差，没必要创建索引（因为即使建立索引，还是有可能全表扫描）

3、在选择索引列的时候，越短越好，可以指定某些列的一部分，没必要用全部字段的值

4、不要给表中的每一个字段都创建索引，并不是索引越多越好

5、定义有外键的数据列一定要创建索引

6、更新频繁的字段不要有索引

7、创建索引的列不要过多，可以创建组合索引，但是组合索引的列的个数不建议太多

8、大文本、大对象不要创建索引

# 聚簇索引和非聚簇索引区别?

聚簇索引是将数据存储与索引放到了一起，非聚簇索引是将数据与索引分开存储，MyIsam 的B+树的叶子节点记录的是真实数据的存储地址。

![img](./assets/image-20220227130938278.png)


![img](./assets/image-20220227130954259.png)

mysql的索引类型跟存储引擎是相关的，innodb存储引擎数据文件跟索引文件全部放在ibd文件中，而myisam的数据文件放在myd文件中，索引放在myi文件中，其实区分聚簇索引和非聚簇索引非常简单，只要判断数据跟索引是否存储在一起就可以了。

innodb存储引擎在进行数据插入的时候，数据必须要跟索引放在一起，如果有主键就使用主键，没有主键就使用唯一键，没有唯一键就使用6字节的rowid，因此跟数据绑定在一起的就是聚簇索引，而为了避免数据冗余存储，其他的索引的叶子节点中存储的都是聚簇索引的key值，**因此innodb中既有聚簇索引也有非聚簇索引，而myisam中只有非聚簇索引。**

**参考：** https://cloud.tencent.com/developer/article/1541265


# 索引为什么不使用其他数据结构？

**哈希表这种结构适用于只有等值查询的场景**，比如 Memcached 及其他一些 NoSQL 引擎。哈希表不适用于区间查询。

虽然**有序数组在等值查询和范围查询场景中的性能就都非常优秀**，但是在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，**有序数组索引只适用于静态存储引擎**，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

二叉树会随着数据的增加树高越来越高，查询效率也越来越低。而且范围查询效率也很低，需要回旋查找。

同样b树虽然解决了二叉树树高越来越高的问题，但是在返回查找时还是需要回旋查找。

以 InnoDB 的一个整数字段索引为例，这个 N 叉树的 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。


![img](./assets/image-20220227112218602.png)

b+树叶子结点有指针相连接，范围查找直接通过指针找到下一个元素，叶子结点已经排好序了。

![img](./assets/image-20220227112246500.png)

B+树与B树的不同：

- B+树非叶子节点不存在数据只存索引，B树非叶子节点存储数据

- B+树查询效率更高。B+树使用双向链表串连所有叶子节点，区间查询效率更高（因为所有数据都在B+树的叶子节点，扫描数据库 只需扫一遍叶子结点就行了），但是B树则需要通过中序遍历才能完成查询范围的查找。

- B+树查询效率更稳定。B+树每次都必须查询到叶子节点才能找到数据，而B树查询的数据可能不在叶子节点，也可能在，这样就会造成查询的效率的不稳定

- B+树的磁盘读写代价更小。B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，通常B+树矮更胖，高度小查询产生的I/O更少。（通常一个节点大小会设置为磁盘页大小，而B+树的非叶子节点中不保存数据，每个节点可放更多的key，这样一个索引页中能查询到很多索引，降低了下一次去磁盘再拿索引页的可能性，这样就降低了磁盘的IO了。B树中非叶子节点会保存数据，这样B树每个节点可放的key则少，这样就造成了，B树的高度会比B+树更高，从而会产生更多的磁盘IO消耗。（因为一个结点的空间是有限的，B树要存放索引+数据，而 B+树只需要存放索引））


**参考：** https://www.bilibili.com/video/BV1t5411u7Fg?p=2	

# mysql索引数据结构

MySQL 主要用到两种结构：B+ Tree 索引和 Hash 索引。

Inodb 存储引擎 默认是 B+Tree索引。Memory 存储引擎 默认 Hash索引。

MySQL 中，只有 Memory(Memory 表只存在内存中，断电会消失，适用于临时表)存储引擎显示支持 Hash 索引，是 Memory 表的默认索引类型，尽管 Memory 表也可以使用 B+Tree 索引。Hash 索引把数据以 hash 形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为 hash 结构，每个键只对应一个值，而且是散列的方式分布。所以它并不支持范围查找和排序等功能。

B+Tree 是 mysql 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎模式的索引类型。相对 Hash 索引，B+Tree 在查找单条记录的速度比不上 Hash 索引，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。

对比：

hash类型的索引：查询单条快，范围查询慢。

btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）。

# mysql中索引类型有哪些？

普通索引：允许被索引的数据列包含重复的值

唯一索引：可以保证数据记录的唯一性

主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字primary key来创建

联合索引：索引可以覆盖多个数据列

全文索引：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术
