# 重复消费

消息在生产和消费的过程中都可能会产生重复，所以你要做的是，在生产过程和消费过程中增加消息幂等性的保证，这样就可以认为从 **最终结果上来看**，消息实际上是只被消费了一次的。



## 生产端

**在消息生产过程中，** 在 Kafka0.11 版本和 Pulsar 中都支持 `producer idempotency` 的特性，翻译过来就是生产过程的幂等性，**这种特性保证消息虽然可能在生产端产生重复，但是最终在消息队列存储时只会存储一份** 。

它的做法是给每一个生产者一个唯一的 ID，并且为生产的每一条消息赋予一个唯一 ID，消息队列的服务端会存储 `< 生产者 ID，最后一条消息 ID>` 的映射。当某一个生产者产生新的消息时，消息队列服务端会比对消息 ID 是否与存储的最后一条 ID 一致，如果一致，就认为是重复的消息，服务端会自动丢弃。



## 消费端

**而在消费端** ， 幂等性的保证会稍微复杂一些，你可以从 **通用层** 和 **业务层** 两个层面来考虑。

在通用层面，你可以在消息被生产的时候，使用发号器给它生成一个全局唯一的消息 ID，消息被处理之后，把这个 ID 存储在数据库中，在处理下一条消息之前，先从数据库里面查询这个全局 ID 是否被消费过，如果被消费过就放弃消费。

你可以看到，无论是生产端的幂等性保证方式，还是消费端通用的幂等性保证方式，它们的共同特点都是为每一个消息生成一个唯一的 ID，然后在使用这个消息的时候，先比对这个 ID 是否已经存在，如果存在，则认为消息已经被使用过。所以这种方式是一种标准的实现幂等的方式， **你在项目之中可以拿来直接使用，** 它在逻辑上的伪代码就像下面这样：

```java
boolean isIDExisted = selectByID(ID); // 判断 ID 是否存在
if(isIDExisted) {
  return; // 存在则直接返回
} else {
  process(message); // 不存在，则处理消息
  saveID(ID);   // 存储 ID
}
```

**不过这样会有一个问题：** 如果消息在处理之后，还没有来得及写入数据库，消费者宕机了重启之后发现数据库中并没有这条消息，还是会重复执行两次消费逻辑，这时你就需要引入事务机制，保证消息处理和写入数据库必须同时成功或者同时失败，但是这样消息处理的成本就更高了，所以，如果对于消息重复没有特别严格的要求，可以直接使用这种通用的方案，而不考虑引入事务。



## 业务端

**在业务层面怎么处理呢？** 这里有很多种处理方式，其中有一种是增加乐观锁的方式。比如，你的消息处理程序需要给一个人的账号加钱，那么你可以通过乐观锁的方式来解决。

**具体的操作方式是这样的：** 你给每个人的账号数据中增加一个版本号的字段，在生产消息时先查询这个账户的版本号，并且将版本号连同消息一起发送给消息队列。消费端在拿到消息和版本号后，在执行更新账户金额 SQL 的时候带上版本号，类似于执行：

```sql
update user set amount = amount + 20, version=version+1 where userId=1 and version=1;
```

你看，我们在更新数据时给数据加了乐观锁，这样在消费第一条消息时，version 值为 1，SQL 可以执行成功，并且同时把 version 值改为了 2；在执行第二条相同的消息时，由于 version 值不再是 1，所以这条 SQL 不能执行成功，也就保证了消息的幂等性。