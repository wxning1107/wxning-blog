# 池化技术

## MySQL连接耗时

抓包：

```sh
tcpdump -i bond0 -nn -tttt port 4490
```

抓取了线上 MySQL 建立连接的网络包来做分析，从抓包结果来看，整个 MySQL 的连接过程可以分为两部分：

![img](./assets/image-20211022135000780.png)

- **第一部分是前三个数据包**

  第一个数据包是客户端向服务端发送的一个 SYN 包，

  第二个包是服务端回给客户端的 ACK 包以及一个 SYN 包，

  第三个包是客户端回给服务端的 ACK 包，熟悉 TCP 协议的同学可以看出这是一个 TCP 的三次握手过程。

- **第二部分是 MySQL 服务端校验客户端密码的过程。**

  其中第一个包是服务端发给客户端要求认证的报文，

  第二和第三个包是客户端将加密后的密码发送给服务端的包，

  最后两个包是服务端回给客户端认证 OK 的报文。

从图中，你可以看到整个连接过程大概消耗了 4ms（969012-964904）。所以，数据库建连耗时甚至比一个sql执行时间还要久，采用数据库连接池


## Java线程池

JDK 1.5 中引入的 `ThreadPoolExecutor` 就是一种线程池的实现，它有两个重要的参数：`coreThreadCount` 和 `maxThreadCount`，这两个参数控制着线程池的执行过程：

- 如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；
- 如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；
- 当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；
- 当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。

![img](./assets/image-20211022135353675.png)

JDK 实现的这个线程池优 **先把任务放入队列暂存起来，而不是创建更多的线程** 